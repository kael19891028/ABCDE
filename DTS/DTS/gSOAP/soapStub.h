/* soapStub.h
   Generated by gSOAP 2.8.51 for JHService.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#define SOAP_NAMESPACE_OF_tempuri	"http://tempuri.org/"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20851
# error "GSOAP VERSION 20851 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class _tempuri__test;	/* JHService.h:139 */
class _tempuri__testResponse;	/* JHService.h:142 */
class _tempuri__ToolingTimes;	/* JHService.h:145 */
class _tempuri__ToolingTimesResponse;	/* JHService.h:148 */
class _tempuri__BillState;	/* JHService.h:151 */
class _tempuri__BillStateResponse;	/* JHService.h:154 */
class _tempuri__LineInventory;	/* JHService.h:157 */
class _tempuri__LineInventoryResponse;	/* JHService.h:160 */
class _tempuri__AnDonStart;	/* JHService.h:163 */
class _tempuri__AnDonStartResponse;	/* JHService.h:166 */
class _tempuri__AnDonList;	/* JHService.h:169 */
class _tempuri__AnDonListResponse;	/* JHService.h:172 */
class _tempuri__AnDonOver;	/* JHService.h:175 */
class _tempuri__AnDonOverResponse;	/* JHService.h:178 */
class _tempuri__DocAdd;	/* JHService.h:181 */
class _tempuri__DocAddResponse;	/* JHService.h:184 */
struct __tempuri__test;	/* JHService.h:745 */
struct __tempuri__ToolingTimes;	/* JHService.h:815 */
struct __tempuri__BillState;	/* JHService.h:885 */
struct __tempuri__LineInventory;	/* JHService.h:955 */
struct __tempuri__AnDonStart;	/* JHService.h:1025 */
struct __tempuri__AnDonList;	/* JHService.h:1095 */
struct __tempuri__AnDonOver;	/* JHService.h:1165 */
struct __tempuri__DocAdd;	/* JHService.h:1235 */
struct __tempuri__test_;	/* JHService.h:1305 */
struct __tempuri__ToolingTimes_;	/* JHService.h:1375 */
struct __tempuri__BillState_;	/* JHService.h:1445 */
struct __tempuri__LineInventory_;	/* JHService.h:1515 */
struct __tempuri__AnDonStart_;	/* JHService.h:1585 */
struct __tempuri__AnDonList_;	/* JHService.h:1655 */
struct __tempuri__AnDonOver_;	/* JHService.h:1725 */
struct __tempuri__DocAdd_;	/* JHService.h:1795 */

/* JHService.h:139 */
#ifndef SOAP_TYPE__tempuri__test
#define SOAP_TYPE__tempuri__test (7)
/* complex XSD type 'tempuri:test': */
class SOAP_CMAC _tempuri__test {
      public:
        /// Required element 'tempuri:i' of XSD type 'xsd:int'
        int i;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__test
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__test; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__test, default initialized and not managed by a soap context
        virtual _tempuri__test *soap_alloc(void) const { return SOAP_NEW(_tempuri__test); }
      public:
        /// Constructor with initializations
        _tempuri__test() : i(), soap() { }
        virtual ~_tempuri__test() { }
        /// Friend allocator used by soap_new__tempuri__test(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__test * SOAP_FMAC2 soap_instantiate__tempuri__test(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:142 */
#ifndef SOAP_TYPE__tempuri__testResponse
#define SOAP_TYPE__tempuri__testResponse (8)
/* complex XSD type 'tempuri:testResponse': */
class SOAP_CMAC _tempuri__testResponse {
      public:
        /// Optional element 'tempuri:testResult' of XSD type 'xsd:string'
        char *testResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__testResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__testResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__testResponse, default initialized and not managed by a soap context
        virtual _tempuri__testResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__testResponse); }
      public:
        /// Constructor with initializations
        _tempuri__testResponse() : testResult(), soap() { }
        virtual ~_tempuri__testResponse() { }
        /// Friend allocator used by soap_new__tempuri__testResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__testResponse * SOAP_FMAC2 soap_instantiate__tempuri__testResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:145 */
#ifndef SOAP_TYPE__tempuri__ToolingTimes
#define SOAP_TYPE__tempuri__ToolingTimes (9)
/* complex XSD type 'tempuri:ToolingTimes': */
class SOAP_CMAC _tempuri__ToolingTimes {
      public:
        /// Optional element 'tempuri:BillCode' of XSD type 'xsd:string'
        char *BillCode;
        /// Optional element 'tempuri:ToolingCode' of XSD type 'xsd:string'
        char *ToolingCode;
        /// Required element 'tempuri:Times' of XSD type 'xsd:int'
        int Times;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__ToolingTimes
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__ToolingTimes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__ToolingTimes, default initialized and not managed by a soap context
        virtual _tempuri__ToolingTimes *soap_alloc(void) const { return SOAP_NEW(_tempuri__ToolingTimes); }
      public:
        /// Constructor with initializations
        _tempuri__ToolingTimes() : BillCode(), ToolingCode(), Times(), soap() { }
        virtual ~_tempuri__ToolingTimes() { }
        /// Friend allocator used by soap_new__tempuri__ToolingTimes(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__ToolingTimes * SOAP_FMAC2 soap_instantiate__tempuri__ToolingTimes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:148 */
#ifndef SOAP_TYPE__tempuri__ToolingTimesResponse
#define SOAP_TYPE__tempuri__ToolingTimesResponse (10)
/* complex XSD type 'tempuri:ToolingTimesResponse': */
class SOAP_CMAC _tempuri__ToolingTimesResponse {
      public:
        /// Optional element 'tempuri:ToolingTimesResult' of XSD type 'xsd:string'
        char *ToolingTimesResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__ToolingTimesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__ToolingTimesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__ToolingTimesResponse, default initialized and not managed by a soap context
        virtual _tempuri__ToolingTimesResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__ToolingTimesResponse); }
      public:
        /// Constructor with initializations
        _tempuri__ToolingTimesResponse() : ToolingTimesResult(), soap() { }
        virtual ~_tempuri__ToolingTimesResponse() { }
        /// Friend allocator used by soap_new__tempuri__ToolingTimesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__ToolingTimesResponse * SOAP_FMAC2 soap_instantiate__tempuri__ToolingTimesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:151 */
#ifndef SOAP_TYPE__tempuri__BillState
#define SOAP_TYPE__tempuri__BillState (11)
/* complex XSD type 'tempuri:BillState': */
class SOAP_CMAC _tempuri__BillState {
      public:
        /// Optional element 'tempuri:BillCode' of XSD type 'xsd:string'
        char *BillCode;
        /// Required element 'tempuri:OverTotal' of XSD type 'xsd:int'
        int OverTotal;
        /// Optional element 'tempuri:OverTime' of XSD type 'xsd:string'
        char *OverTime;
        /// Required element 'tempuri:State' of XSD type 'xsd:int'
        int State;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__BillState
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__BillState; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__BillState, default initialized and not managed by a soap context
        virtual _tempuri__BillState *soap_alloc(void) const { return SOAP_NEW(_tempuri__BillState); }
      public:
        /// Constructor with initializations
        _tempuri__BillState() : BillCode(), OverTotal(), OverTime(), State(), soap() { }
        virtual ~_tempuri__BillState() { }
        /// Friend allocator used by soap_new__tempuri__BillState(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__BillState * SOAP_FMAC2 soap_instantiate__tempuri__BillState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:154 */
#ifndef SOAP_TYPE__tempuri__BillStateResponse
#define SOAP_TYPE__tempuri__BillStateResponse (12)
/* complex XSD type 'tempuri:BillStateResponse': */
class SOAP_CMAC _tempuri__BillStateResponse {
      public:
        /// Optional element 'tempuri:BillStateResult' of XSD type 'xsd:string'
        char *BillStateResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__BillStateResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__BillStateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__BillStateResponse, default initialized and not managed by a soap context
        virtual _tempuri__BillStateResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__BillStateResponse); }
      public:
        /// Constructor with initializations
        _tempuri__BillStateResponse() : BillStateResult(), soap() { }
        virtual ~_tempuri__BillStateResponse() { }
        /// Friend allocator used by soap_new__tempuri__BillStateResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__BillStateResponse * SOAP_FMAC2 soap_instantiate__tempuri__BillStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:157 */
#ifndef SOAP_TYPE__tempuri__LineInventory
#define SOAP_TYPE__tempuri__LineInventory (13)
/* complex XSD type 'tempuri:LineInventory': */
class SOAP_CMAC _tempuri__LineInventory {
      public:
        /// Optional element 'tempuri:WorkLineCode' of XSD type 'xsd:string'
        char *WorkLineCode;
        /// Optional element 'tempuri:BillCode' of XSD type 'xsd:string'
        char *BillCode;
        /// Optional element 'tempuri:BarCode' of XSD type 'xsd:string'
        char *BarCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__LineInventory
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__LineInventory; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__LineInventory, default initialized and not managed by a soap context
        virtual _tempuri__LineInventory *soap_alloc(void) const { return SOAP_NEW(_tempuri__LineInventory); }
      public:
        /// Constructor with initializations
        _tempuri__LineInventory() : WorkLineCode(), BillCode(), BarCode(), soap() { }
        virtual ~_tempuri__LineInventory() { }
        /// Friend allocator used by soap_new__tempuri__LineInventory(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__LineInventory * SOAP_FMAC2 soap_instantiate__tempuri__LineInventory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:160 */
#ifndef SOAP_TYPE__tempuri__LineInventoryResponse
#define SOAP_TYPE__tempuri__LineInventoryResponse (14)
/* complex XSD type 'tempuri:LineInventoryResponse': */
class SOAP_CMAC _tempuri__LineInventoryResponse {
      public:
        /// Optional element 'tempuri:LineInventoryResult' of XSD type 'xsd:string'
        char *LineInventoryResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__LineInventoryResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__LineInventoryResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__LineInventoryResponse, default initialized and not managed by a soap context
        virtual _tempuri__LineInventoryResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__LineInventoryResponse); }
      public:
        /// Constructor with initializations
        _tempuri__LineInventoryResponse() : LineInventoryResult(), soap() { }
        virtual ~_tempuri__LineInventoryResponse() { }
        /// Friend allocator used by soap_new__tempuri__LineInventoryResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__LineInventoryResponse * SOAP_FMAC2 soap_instantiate__tempuri__LineInventoryResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:163 */
#ifndef SOAP_TYPE__tempuri__AnDonStart
#define SOAP_TYPE__tempuri__AnDonStart (15)
/* complex XSD type 'tempuri:AnDonStart': */
class SOAP_CMAC _tempuri__AnDonStart {
      public:
        /// Optional element 'tempuri:CallTypeCode' of XSD type 'xsd:string'
        char *CallTypeCode;
        /// Optional element 'tempuri:Remark' of XSD type 'xsd:string'
        char *Remark;
        /// Optional element 'tempuri:WorkLineCode' of XSD type 'xsd:string'
        char *WorkLineCode;
        /// Optional element 'tempuri:WorkStationCode' of XSD type 'xsd:string'
        char *WorkStationCode;
        /// Optional element 'tempuri:UserCode' of XSD type 'xsd:string'
        char *UserCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__AnDonStart
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__AnDonStart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__AnDonStart, default initialized and not managed by a soap context
        virtual _tempuri__AnDonStart *soap_alloc(void) const { return SOAP_NEW(_tempuri__AnDonStart); }
      public:
        /// Constructor with initializations
        _tempuri__AnDonStart() : CallTypeCode(), Remark(), WorkLineCode(), WorkStationCode(), UserCode(), soap() { }
        virtual ~_tempuri__AnDonStart() { }
        /// Friend allocator used by soap_new__tempuri__AnDonStart(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__AnDonStart * SOAP_FMAC2 soap_instantiate__tempuri__AnDonStart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:166 */
#ifndef SOAP_TYPE__tempuri__AnDonStartResponse
#define SOAP_TYPE__tempuri__AnDonStartResponse (16)
/* complex XSD type 'tempuri:AnDonStartResponse': */
class SOAP_CMAC _tempuri__AnDonStartResponse {
      public:
        /// Optional element 'tempuri:AnDonStartResult' of XSD type 'xsd:string'
        char *AnDonStartResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__AnDonStartResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__AnDonStartResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__AnDonStartResponse, default initialized and not managed by a soap context
        virtual _tempuri__AnDonStartResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__AnDonStartResponse); }
      public:
        /// Constructor with initializations
        _tempuri__AnDonStartResponse() : AnDonStartResult(), soap() { }
        virtual ~_tempuri__AnDonStartResponse() { }
        /// Friend allocator used by soap_new__tempuri__AnDonStartResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__AnDonStartResponse * SOAP_FMAC2 soap_instantiate__tempuri__AnDonStartResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:169 */
#ifndef SOAP_TYPE__tempuri__AnDonList
#define SOAP_TYPE__tempuri__AnDonList (17)
/* complex XSD type 'tempuri:AnDonList': */
class SOAP_CMAC _tempuri__AnDonList {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__AnDonList
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__AnDonList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__AnDonList, default initialized and not managed by a soap context
        virtual _tempuri__AnDonList *soap_alloc(void) const { return SOAP_NEW(_tempuri__AnDonList); }
      public:
        /// Constructor with initializations
        _tempuri__AnDonList() : soap() { }
        virtual ~_tempuri__AnDonList() { }
        /// Friend allocator used by soap_new__tempuri__AnDonList(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__AnDonList * SOAP_FMAC2 soap_instantiate__tempuri__AnDonList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:172 */
#ifndef SOAP_TYPE__tempuri__AnDonListResponse
#define SOAP_TYPE__tempuri__AnDonListResponse (18)
/* complex XSD type 'tempuri:AnDonListResponse': */
class SOAP_CMAC _tempuri__AnDonListResponse {
      public:
        /// Optional element 'tempuri:AnDonListResult' of XSD type 'xsd:string'
        char *AnDonListResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__AnDonListResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__AnDonListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__AnDonListResponse, default initialized and not managed by a soap context
        virtual _tempuri__AnDonListResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__AnDonListResponse); }
      public:
        /// Constructor with initializations
        _tempuri__AnDonListResponse() : AnDonListResult(), soap() { }
        virtual ~_tempuri__AnDonListResponse() { }
        /// Friend allocator used by soap_new__tempuri__AnDonListResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__AnDonListResponse * SOAP_FMAC2 soap_instantiate__tempuri__AnDonListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:175 */
#ifndef SOAP_TYPE__tempuri__AnDonOver
#define SOAP_TYPE__tempuri__AnDonOver (19)
/* complex XSD type 'tempuri:AnDonOver': */
class SOAP_CMAC _tempuri__AnDonOver {
      public:
        /// Optional element 'tempuri:AnDonCode' of XSD type 'xsd:string'
        char *AnDonCode;
        /// Optional element 'tempuri:HandleUser' of XSD type 'xsd:string'
        char *HandleUser;
        /// Optional element 'tempuri:HandleRemark' of XSD type 'xsd:string'
        char *HandleRemark;
        /// Optional element 'tempuri:HandleTime' of XSD type 'xsd:string'
        char *HandleTime;
        /// Optional element 'tempuri:State' of XSD type 'xsd:string'
        char *State;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__AnDonOver
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__AnDonOver; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__AnDonOver, default initialized and not managed by a soap context
        virtual _tempuri__AnDonOver *soap_alloc(void) const { return SOAP_NEW(_tempuri__AnDonOver); }
      public:
        /// Constructor with initializations
        _tempuri__AnDonOver() : AnDonCode(), HandleUser(), HandleRemark(), HandleTime(), State(), soap() { }
        virtual ~_tempuri__AnDonOver() { }
        /// Friend allocator used by soap_new__tempuri__AnDonOver(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__AnDonOver * SOAP_FMAC2 soap_instantiate__tempuri__AnDonOver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:178 */
#ifndef SOAP_TYPE__tempuri__AnDonOverResponse
#define SOAP_TYPE__tempuri__AnDonOverResponse (20)
/* complex XSD type 'tempuri:AnDonOverResponse': */
class SOAP_CMAC _tempuri__AnDonOverResponse {
      public:
        /// Optional element 'tempuri:AnDonOverResult' of XSD type 'xsd:string'
        char *AnDonOverResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__AnDonOverResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__AnDonOverResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__AnDonOverResponse, default initialized and not managed by a soap context
        virtual _tempuri__AnDonOverResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__AnDonOverResponse); }
      public:
        /// Constructor with initializations
        _tempuri__AnDonOverResponse() : AnDonOverResult(), soap() { }
        virtual ~_tempuri__AnDonOverResponse() { }
        /// Friend allocator used by soap_new__tempuri__AnDonOverResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__AnDonOverResponse * SOAP_FMAC2 soap_instantiate__tempuri__AnDonOverResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:181 */
#ifndef SOAP_TYPE__tempuri__DocAdd
#define SOAP_TYPE__tempuri__DocAdd (21)
/* complex XSD type 'tempuri:DocAdd': */
class SOAP_CMAC _tempuri__DocAdd {
      public:
        /// Optional element 'tempuri:DocTypeCode' of XSD type 'xsd:string'
        char *DocTypeCode;
        /// Optional element 'tempuri:DocXml' of XSD type 'xsd:string'
        char *DocXml;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__DocAdd
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__DocAdd; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__DocAdd, default initialized and not managed by a soap context
        virtual _tempuri__DocAdd *soap_alloc(void) const { return SOAP_NEW(_tempuri__DocAdd); }
      public:
        /// Constructor with initializations
        _tempuri__DocAdd() : DocTypeCode(), DocXml(), soap() { }
        virtual ~_tempuri__DocAdd() { }
        /// Friend allocator used by soap_new__tempuri__DocAdd(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__DocAdd * SOAP_FMAC2 soap_instantiate__tempuri__DocAdd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:184 */
#ifndef SOAP_TYPE__tempuri__DocAddResponse
#define SOAP_TYPE__tempuri__DocAddResponse (22)
/* complex XSD type 'tempuri:DocAddResponse': */
class SOAP_CMAC _tempuri__DocAddResponse {
      public:
        /// Optional element 'tempuri:DocAddResult' of XSD type 'xsd:string'
        char *DocAddResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tempuri__DocAddResponse
        virtual int soap_type(void) const { return SOAP_TYPE__tempuri__DocAddResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tempuri__DocAddResponse, default initialized and not managed by a soap context
        virtual _tempuri__DocAddResponse *soap_alloc(void) const { return SOAP_NEW(_tempuri__DocAddResponse); }
      public:
        /// Constructor with initializations
        _tempuri__DocAddResponse() : DocAddResult(), soap() { }
        virtual ~_tempuri__DocAddResponse() { }
        /// Friend allocator used by soap_new__tempuri__DocAddResponse(struct soap*, int)
        friend SOAP_FMAC1 _tempuri__DocAddResponse * SOAP_FMAC2 soap_instantiate__tempuri__DocAddResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:745 */
#ifndef SOAP_TYPE___tempuri__test
#define SOAP_TYPE___tempuri__test (27)
/* Wrapper: */
struct SOAP_CMAC __tempuri__test {
      public:
        /** Optional element 'tempuri:test' of XSD type 'tempuri:test' */
        _tempuri__test *tempuri__test;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__test */
        int soap_type() const { return SOAP_TYPE___tempuri__test; }
        /** Constructor with member initializations */
        __tempuri__test() : tempuri__test() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__test * SOAP_FMAC2 soap_instantiate___tempuri__test(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:815 */
#ifndef SOAP_TYPE___tempuri__ToolingTimes
#define SOAP_TYPE___tempuri__ToolingTimes (31)
/* Wrapper: */
struct SOAP_CMAC __tempuri__ToolingTimes {
      public:
        /** Optional element 'tempuri:ToolingTimes' of XSD type 'tempuri:ToolingTimes' */
        _tempuri__ToolingTimes *tempuri__ToolingTimes;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__ToolingTimes */
        int soap_type() const { return SOAP_TYPE___tempuri__ToolingTimes; }
        /** Constructor with member initializations */
        __tempuri__ToolingTimes() : tempuri__ToolingTimes() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__ToolingTimes * SOAP_FMAC2 soap_instantiate___tempuri__ToolingTimes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:885 */
#ifndef SOAP_TYPE___tempuri__BillState
#define SOAP_TYPE___tempuri__BillState (35)
/* Wrapper: */
struct SOAP_CMAC __tempuri__BillState {
      public:
        /** Optional element 'tempuri:BillState' of XSD type 'tempuri:BillState' */
        _tempuri__BillState *tempuri__BillState;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__BillState */
        int soap_type() const { return SOAP_TYPE___tempuri__BillState; }
        /** Constructor with member initializations */
        __tempuri__BillState() : tempuri__BillState() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__BillState * SOAP_FMAC2 soap_instantiate___tempuri__BillState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:955 */
#ifndef SOAP_TYPE___tempuri__LineInventory
#define SOAP_TYPE___tempuri__LineInventory (39)
/* Wrapper: */
struct SOAP_CMAC __tempuri__LineInventory {
      public:
        /** Optional element 'tempuri:LineInventory' of XSD type 'tempuri:LineInventory' */
        _tempuri__LineInventory *tempuri__LineInventory;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__LineInventory */
        int soap_type() const { return SOAP_TYPE___tempuri__LineInventory; }
        /** Constructor with member initializations */
        __tempuri__LineInventory() : tempuri__LineInventory() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__LineInventory * SOAP_FMAC2 soap_instantiate___tempuri__LineInventory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:1025 */
#ifndef SOAP_TYPE___tempuri__AnDonStart
#define SOAP_TYPE___tempuri__AnDonStart (43)
/* Wrapper: */
struct SOAP_CMAC __tempuri__AnDonStart {
      public:
        /** Optional element 'tempuri:AnDonStart' of XSD type 'tempuri:AnDonStart' */
        _tempuri__AnDonStart *tempuri__AnDonStart;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__AnDonStart */
        int soap_type() const { return SOAP_TYPE___tempuri__AnDonStart; }
        /** Constructor with member initializations */
        __tempuri__AnDonStart() : tempuri__AnDonStart() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__AnDonStart * SOAP_FMAC2 soap_instantiate___tempuri__AnDonStart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:1095 */
#ifndef SOAP_TYPE___tempuri__AnDonList
#define SOAP_TYPE___tempuri__AnDonList (47)
/* Wrapper: */
struct SOAP_CMAC __tempuri__AnDonList {
      public:
        /** Optional element 'tempuri:AnDonList' of XSD type 'tempuri:AnDonList' */
        _tempuri__AnDonList *tempuri__AnDonList;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__AnDonList */
        int soap_type() const { return SOAP_TYPE___tempuri__AnDonList; }
        /** Constructor with member initializations */
        __tempuri__AnDonList() : tempuri__AnDonList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__AnDonList * SOAP_FMAC2 soap_instantiate___tempuri__AnDonList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:1165 */
#ifndef SOAP_TYPE___tempuri__AnDonOver
#define SOAP_TYPE___tempuri__AnDonOver (51)
/* Wrapper: */
struct SOAP_CMAC __tempuri__AnDonOver {
      public:
        /** Optional element 'tempuri:AnDonOver' of XSD type 'tempuri:AnDonOver' */
        _tempuri__AnDonOver *tempuri__AnDonOver;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__AnDonOver */
        int soap_type() const { return SOAP_TYPE___tempuri__AnDonOver; }
        /** Constructor with member initializations */
        __tempuri__AnDonOver() : tempuri__AnDonOver() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__AnDonOver * SOAP_FMAC2 soap_instantiate___tempuri__AnDonOver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:1235 */
#ifndef SOAP_TYPE___tempuri__DocAdd
#define SOAP_TYPE___tempuri__DocAdd (55)
/* Wrapper: */
struct SOAP_CMAC __tempuri__DocAdd {
      public:
        /** Optional element 'tempuri:DocAdd' of XSD type 'tempuri:DocAdd' */
        _tempuri__DocAdd *tempuri__DocAdd;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__DocAdd */
        int soap_type() const { return SOAP_TYPE___tempuri__DocAdd; }
        /** Constructor with member initializations */
        __tempuri__DocAdd() : tempuri__DocAdd() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__DocAdd * SOAP_FMAC2 soap_instantiate___tempuri__DocAdd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:1305 */
#ifndef SOAP_TYPE___tempuri__test_
#define SOAP_TYPE___tempuri__test_ (57)
/* Wrapper: */
struct SOAP_CMAC __tempuri__test_ {
      public:
        /** Optional element 'tempuri:test' of XSD type 'tempuri:test' */
        _tempuri__test *tempuri__test;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__test_ */
        int soap_type() const { return SOAP_TYPE___tempuri__test_; }
        /** Constructor with member initializations */
        __tempuri__test_() : tempuri__test() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__test_ * SOAP_FMAC2 soap_instantiate___tempuri__test_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:1375 */
#ifndef SOAP_TYPE___tempuri__ToolingTimes_
#define SOAP_TYPE___tempuri__ToolingTimes_ (59)
/* Wrapper: */
struct SOAP_CMAC __tempuri__ToolingTimes_ {
      public:
        /** Optional element 'tempuri:ToolingTimes' of XSD type 'tempuri:ToolingTimes' */
        _tempuri__ToolingTimes *tempuri__ToolingTimes;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__ToolingTimes_ */
        int soap_type() const { return SOAP_TYPE___tempuri__ToolingTimes_; }
        /** Constructor with member initializations */
        __tempuri__ToolingTimes_() : tempuri__ToolingTimes() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__ToolingTimes_ * SOAP_FMAC2 soap_instantiate___tempuri__ToolingTimes_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:1445 */
#ifndef SOAP_TYPE___tempuri__BillState_
#define SOAP_TYPE___tempuri__BillState_ (61)
/* Wrapper: */
struct SOAP_CMAC __tempuri__BillState_ {
      public:
        /** Optional element 'tempuri:BillState' of XSD type 'tempuri:BillState' */
        _tempuri__BillState *tempuri__BillState;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__BillState_ */
        int soap_type() const { return SOAP_TYPE___tempuri__BillState_; }
        /** Constructor with member initializations */
        __tempuri__BillState_() : tempuri__BillState() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__BillState_ * SOAP_FMAC2 soap_instantiate___tempuri__BillState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:1515 */
#ifndef SOAP_TYPE___tempuri__LineInventory_
#define SOAP_TYPE___tempuri__LineInventory_ (63)
/* Wrapper: */
struct SOAP_CMAC __tempuri__LineInventory_ {
      public:
        /** Optional element 'tempuri:LineInventory' of XSD type 'tempuri:LineInventory' */
        _tempuri__LineInventory *tempuri__LineInventory;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__LineInventory_ */
        int soap_type() const { return SOAP_TYPE___tempuri__LineInventory_; }
        /** Constructor with member initializations */
        __tempuri__LineInventory_() : tempuri__LineInventory() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__LineInventory_ * SOAP_FMAC2 soap_instantiate___tempuri__LineInventory_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:1585 */
#ifndef SOAP_TYPE___tempuri__AnDonStart_
#define SOAP_TYPE___tempuri__AnDonStart_ (65)
/* Wrapper: */
struct SOAP_CMAC __tempuri__AnDonStart_ {
      public:
        /** Optional element 'tempuri:AnDonStart' of XSD type 'tempuri:AnDonStart' */
        _tempuri__AnDonStart *tempuri__AnDonStart;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__AnDonStart_ */
        int soap_type() const { return SOAP_TYPE___tempuri__AnDonStart_; }
        /** Constructor with member initializations */
        __tempuri__AnDonStart_() : tempuri__AnDonStart() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__AnDonStart_ * SOAP_FMAC2 soap_instantiate___tempuri__AnDonStart_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:1655 */
#ifndef SOAP_TYPE___tempuri__AnDonList_
#define SOAP_TYPE___tempuri__AnDonList_ (67)
/* Wrapper: */
struct SOAP_CMAC __tempuri__AnDonList_ {
      public:
        /** Optional element 'tempuri:AnDonList' of XSD type 'tempuri:AnDonList' */
        _tempuri__AnDonList *tempuri__AnDonList;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__AnDonList_ */
        int soap_type() const { return SOAP_TYPE___tempuri__AnDonList_; }
        /** Constructor with member initializations */
        __tempuri__AnDonList_() : tempuri__AnDonList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__AnDonList_ * SOAP_FMAC2 soap_instantiate___tempuri__AnDonList_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:1725 */
#ifndef SOAP_TYPE___tempuri__AnDonOver_
#define SOAP_TYPE___tempuri__AnDonOver_ (69)
/* Wrapper: */
struct SOAP_CMAC __tempuri__AnDonOver_ {
      public:
        /** Optional element 'tempuri:AnDonOver' of XSD type 'tempuri:AnDonOver' */
        _tempuri__AnDonOver *tempuri__AnDonOver;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__AnDonOver_ */
        int soap_type() const { return SOAP_TYPE___tempuri__AnDonOver_; }
        /** Constructor with member initializations */
        __tempuri__AnDonOver_() : tempuri__AnDonOver() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__AnDonOver_ * SOAP_FMAC2 soap_instantiate___tempuri__AnDonOver_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:1795 */
#ifndef SOAP_TYPE___tempuri__DocAdd_
#define SOAP_TYPE___tempuri__DocAdd_ (71)
/* Wrapper: */
struct SOAP_CMAC __tempuri__DocAdd_ {
      public:
        /** Optional element 'tempuri:DocAdd' of XSD type 'tempuri:DocAdd' */
        _tempuri__DocAdd *tempuri__DocAdd;
      public:
        /** Return unique type id SOAP_TYPE___tempuri__DocAdd_ */
        int soap_type() const { return SOAP_TYPE___tempuri__DocAdd_; }
        /** Constructor with member initializations */
        __tempuri__DocAdd_() : tempuri__DocAdd() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tempuri__DocAdd_ * SOAP_FMAC2 soap_instantiate___tempuri__DocAdd_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* JHService.h:2098 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (72)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* JHService.h:2098 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (73)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* JHService.h:2098 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (75)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* JHService.h:2098 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (78)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* JHService.h:2098 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (79)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* JHService.h:120 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* JHService.h:120 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* _tempuri__DocAddResponse has binding name '_tempuri__DocAddResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__DocAddResponse
#define SOAP_TYPE__tempuri__DocAddResponse (22)
#endif

/* _tempuri__DocAdd has binding name '_tempuri__DocAdd' for type '' */
#ifndef SOAP_TYPE__tempuri__DocAdd
#define SOAP_TYPE__tempuri__DocAdd (21)
#endif

/* _tempuri__AnDonOverResponse has binding name '_tempuri__AnDonOverResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__AnDonOverResponse
#define SOAP_TYPE__tempuri__AnDonOverResponse (20)
#endif

/* _tempuri__AnDonOver has binding name '_tempuri__AnDonOver' for type '' */
#ifndef SOAP_TYPE__tempuri__AnDonOver
#define SOAP_TYPE__tempuri__AnDonOver (19)
#endif

/* _tempuri__AnDonListResponse has binding name '_tempuri__AnDonListResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__AnDonListResponse
#define SOAP_TYPE__tempuri__AnDonListResponse (18)
#endif

/* _tempuri__AnDonList has binding name '_tempuri__AnDonList' for type '' */
#ifndef SOAP_TYPE__tempuri__AnDonList
#define SOAP_TYPE__tempuri__AnDonList (17)
#endif

/* _tempuri__AnDonStartResponse has binding name '_tempuri__AnDonStartResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__AnDonStartResponse
#define SOAP_TYPE__tempuri__AnDonStartResponse (16)
#endif

/* _tempuri__AnDonStart has binding name '_tempuri__AnDonStart' for type '' */
#ifndef SOAP_TYPE__tempuri__AnDonStart
#define SOAP_TYPE__tempuri__AnDonStart (15)
#endif

/* _tempuri__LineInventoryResponse has binding name '_tempuri__LineInventoryResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__LineInventoryResponse
#define SOAP_TYPE__tempuri__LineInventoryResponse (14)
#endif

/* _tempuri__LineInventory has binding name '_tempuri__LineInventory' for type '' */
#ifndef SOAP_TYPE__tempuri__LineInventory
#define SOAP_TYPE__tempuri__LineInventory (13)
#endif

/* _tempuri__BillStateResponse has binding name '_tempuri__BillStateResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__BillStateResponse
#define SOAP_TYPE__tempuri__BillStateResponse (12)
#endif

/* _tempuri__BillState has binding name '_tempuri__BillState' for type '' */
#ifndef SOAP_TYPE__tempuri__BillState
#define SOAP_TYPE__tempuri__BillState (11)
#endif

/* _tempuri__ToolingTimesResponse has binding name '_tempuri__ToolingTimesResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__ToolingTimesResponse
#define SOAP_TYPE__tempuri__ToolingTimesResponse (10)
#endif

/* _tempuri__ToolingTimes has binding name '_tempuri__ToolingTimes' for type '' */
#ifndef SOAP_TYPE__tempuri__ToolingTimes
#define SOAP_TYPE__tempuri__ToolingTimes (9)
#endif

/* _tempuri__testResponse has binding name '_tempuri__testResponse' for type '' */
#ifndef SOAP_TYPE__tempuri__testResponse
#define SOAP_TYPE__tempuri__testResponse (8)
#endif

/* _tempuri__test has binding name '_tempuri__test' for type '' */
#ifndef SOAP_TYPE__tempuri__test
#define SOAP_TYPE__tempuri__test (7)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (79)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (78)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (75)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (73)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (72)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (81)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (80)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (74)
#endif

/* _tempuri__DocAdd * has binding name 'PointerTo_tempuri__DocAdd' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__DocAdd
#define SOAP_TYPE_PointerTo_tempuri__DocAdd (52)
#endif

/* _tempuri__AnDonOver * has binding name 'PointerTo_tempuri__AnDonOver' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__AnDonOver
#define SOAP_TYPE_PointerTo_tempuri__AnDonOver (48)
#endif

/* _tempuri__AnDonList * has binding name 'PointerTo_tempuri__AnDonList' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__AnDonList
#define SOAP_TYPE_PointerTo_tempuri__AnDonList (44)
#endif

/* _tempuri__AnDonStart * has binding name 'PointerTo_tempuri__AnDonStart' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__AnDonStart
#define SOAP_TYPE_PointerTo_tempuri__AnDonStart (40)
#endif

/* _tempuri__LineInventory * has binding name 'PointerTo_tempuri__LineInventory' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__LineInventory
#define SOAP_TYPE_PointerTo_tempuri__LineInventory (36)
#endif

/* _tempuri__BillState * has binding name 'PointerTo_tempuri__BillState' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__BillState
#define SOAP_TYPE_PointerTo_tempuri__BillState (32)
#endif

/* _tempuri__ToolingTimes * has binding name 'PointerTo_tempuri__ToolingTimes' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__ToolingTimes
#define SOAP_TYPE_PointerTo_tempuri__ToolingTimes (28)
#endif

/* _tempuri__test * has binding name 'PointerTo_tempuri__test' for type '' */
#ifndef SOAP_TYPE_PointerTo_tempuri__test
#define SOAP_TYPE_PointerTo_tempuri__test (24)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */

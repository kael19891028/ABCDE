/* soapC.cpp
   Generated by gSOAP 2.8.51 for JHService.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.51 2017-09-18 01:00:35 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTo_tempuri__DocAdd:
		return soap_in_PointerTo_tempuri__DocAdd(soap, NULL, NULL, "tempuri:DocAdd");
	case SOAP_TYPE_PointerTo_tempuri__AnDonOver:
		return soap_in_PointerTo_tempuri__AnDonOver(soap, NULL, NULL, "tempuri:AnDonOver");
	case SOAP_TYPE_PointerTo_tempuri__AnDonList:
		return soap_in_PointerTo_tempuri__AnDonList(soap, NULL, NULL, "tempuri:AnDonList");
	case SOAP_TYPE_PointerTo_tempuri__AnDonStart:
		return soap_in_PointerTo_tempuri__AnDonStart(soap, NULL, NULL, "tempuri:AnDonStart");
	case SOAP_TYPE_PointerTo_tempuri__LineInventory:
		return soap_in_PointerTo_tempuri__LineInventory(soap, NULL, NULL, "tempuri:LineInventory");
	case SOAP_TYPE_PointerTo_tempuri__BillState:
		return soap_in_PointerTo_tempuri__BillState(soap, NULL, NULL, "tempuri:BillState");
	case SOAP_TYPE_PointerTo_tempuri__ToolingTimes:
		return soap_in_PointerTo_tempuri__ToolingTimes(soap, NULL, NULL, "tempuri:ToolingTimes");
	case SOAP_TYPE_PointerTo_tempuri__test:
		return soap_in_PointerTo_tempuri__test(soap, NULL, NULL, "tempuri:test");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "tempuri:DocAddResponse"))
		{	*type = SOAP_TYPE__tempuri__DocAddResponse;
			return soap_in__tempuri__DocAddResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:DocAdd"))
		{	*type = SOAP_TYPE__tempuri__DocAdd;
			return soap_in__tempuri__DocAdd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDonOverResponse"))
		{	*type = SOAP_TYPE__tempuri__AnDonOverResponse;
			return soap_in__tempuri__AnDonOverResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDonOver"))
		{	*type = SOAP_TYPE__tempuri__AnDonOver;
			return soap_in__tempuri__AnDonOver(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDonListResponse"))
		{	*type = SOAP_TYPE__tempuri__AnDonListResponse;
			return soap_in__tempuri__AnDonListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDonList"))
		{	*type = SOAP_TYPE__tempuri__AnDonList;
			return soap_in__tempuri__AnDonList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDonStartResponse"))
		{	*type = SOAP_TYPE__tempuri__AnDonStartResponse;
			return soap_in__tempuri__AnDonStartResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:AnDonStart"))
		{	*type = SOAP_TYPE__tempuri__AnDonStart;
			return soap_in__tempuri__AnDonStart(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:LineInventoryResponse"))
		{	*type = SOAP_TYPE__tempuri__LineInventoryResponse;
			return soap_in__tempuri__LineInventoryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:LineInventory"))
		{	*type = SOAP_TYPE__tempuri__LineInventory;
			return soap_in__tempuri__LineInventory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:BillStateResponse"))
		{	*type = SOAP_TYPE__tempuri__BillStateResponse;
			return soap_in__tempuri__BillStateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:BillState"))
		{	*type = SOAP_TYPE__tempuri__BillState;
			return soap_in__tempuri__BillState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:ToolingTimesResponse"))
		{	*type = SOAP_TYPE__tempuri__ToolingTimesResponse;
			return soap_in__tempuri__ToolingTimesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:ToolingTimes"))
		{	*type = SOAP_TYPE__tempuri__ToolingTimes;
			return soap_in__tempuri__ToolingTimes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:testResponse"))
		{	*type = SOAP_TYPE__tempuri__testResponse;
			return soap_in__tempuri__testResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tempuri:test"))
		{	*type = SOAP_TYPE__tempuri__test;
			return soap_in__tempuri__test(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				if (soap_ignore(soap) || soap_element_end_in(soap, NULL))
					return soap->error;
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE__tempuri__DocAddResponse:
		return ((_tempuri__DocAddResponse *)ptr)->soap_out(soap, "tempuri:DocAddResponse", id, "");
	case SOAP_TYPE__tempuri__DocAdd:
		return ((_tempuri__DocAdd *)ptr)->soap_out(soap, "tempuri:DocAdd", id, "");
	case SOAP_TYPE__tempuri__AnDonOverResponse:
		return ((_tempuri__AnDonOverResponse *)ptr)->soap_out(soap, "tempuri:AnDonOverResponse", id, "");
	case SOAP_TYPE__tempuri__AnDonOver:
		return ((_tempuri__AnDonOver *)ptr)->soap_out(soap, "tempuri:AnDonOver", id, "");
	case SOAP_TYPE__tempuri__AnDonListResponse:
		return ((_tempuri__AnDonListResponse *)ptr)->soap_out(soap, "tempuri:AnDonListResponse", id, "");
	case SOAP_TYPE__tempuri__AnDonList:
		return ((_tempuri__AnDonList *)ptr)->soap_out(soap, "tempuri:AnDonList", id, "");
	case SOAP_TYPE__tempuri__AnDonStartResponse:
		return ((_tempuri__AnDonStartResponse *)ptr)->soap_out(soap, "tempuri:AnDonStartResponse", id, "");
	case SOAP_TYPE__tempuri__AnDonStart:
		return ((_tempuri__AnDonStart *)ptr)->soap_out(soap, "tempuri:AnDonStart", id, "");
	case SOAP_TYPE__tempuri__LineInventoryResponse:
		return ((_tempuri__LineInventoryResponse *)ptr)->soap_out(soap, "tempuri:LineInventoryResponse", id, "");
	case SOAP_TYPE__tempuri__LineInventory:
		return ((_tempuri__LineInventory *)ptr)->soap_out(soap, "tempuri:LineInventory", id, "");
	case SOAP_TYPE__tempuri__BillStateResponse:
		return ((_tempuri__BillStateResponse *)ptr)->soap_out(soap, "tempuri:BillStateResponse", id, "");
	case SOAP_TYPE__tempuri__BillState:
		return ((_tempuri__BillState *)ptr)->soap_out(soap, "tempuri:BillState", id, "");
	case SOAP_TYPE__tempuri__ToolingTimesResponse:
		return ((_tempuri__ToolingTimesResponse *)ptr)->soap_out(soap, "tempuri:ToolingTimesResponse", id, "");
	case SOAP_TYPE__tempuri__ToolingTimes:
		return ((_tempuri__ToolingTimes *)ptr)->soap_out(soap, "tempuri:ToolingTimes", id, "");
	case SOAP_TYPE__tempuri__testResponse:
		return ((_tempuri__testResponse *)ptr)->soap_out(soap, "tempuri:testResponse", id, "");
	case SOAP_TYPE__tempuri__test:
		return ((_tempuri__test *)ptr)->soap_out(soap, "tempuri:test", id, "");
	case SOAP_TYPE_PointerTo_tempuri__DocAdd:
		return soap_out_PointerTo_tempuri__DocAdd(soap, tag, id, (_tempuri__DocAdd *const*)ptr, "tempuri:DocAdd");
	case SOAP_TYPE_PointerTo_tempuri__AnDonOver:
		return soap_out_PointerTo_tempuri__AnDonOver(soap, tag, id, (_tempuri__AnDonOver *const*)ptr, "tempuri:AnDonOver");
	case SOAP_TYPE_PointerTo_tempuri__AnDonList:
		return soap_out_PointerTo_tempuri__AnDonList(soap, tag, id, (_tempuri__AnDonList *const*)ptr, "tempuri:AnDonList");
	case SOAP_TYPE_PointerTo_tempuri__AnDonStart:
		return soap_out_PointerTo_tempuri__AnDonStart(soap, tag, id, (_tempuri__AnDonStart *const*)ptr, "tempuri:AnDonStart");
	case SOAP_TYPE_PointerTo_tempuri__LineInventory:
		return soap_out_PointerTo_tempuri__LineInventory(soap, tag, id, (_tempuri__LineInventory *const*)ptr, "tempuri:LineInventory");
	case SOAP_TYPE_PointerTo_tempuri__BillState:
		return soap_out_PointerTo_tempuri__BillState(soap, tag, id, (_tempuri__BillState *const*)ptr, "tempuri:BillState");
	case SOAP_TYPE_PointerTo_tempuri__ToolingTimes:
		return soap_out_PointerTo_tempuri__ToolingTimes(soap, tag, id, (_tempuri__ToolingTimes *const*)ptr, "tempuri:ToolingTimes");
	case SOAP_TYPE_PointerTo_tempuri__test:
		return soap_out_PointerTo_tempuri__test(soap, tag, id, (_tempuri__test *const*)ptr, "tempuri:test");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__tempuri__DocAddResponse:
		((_tempuri__DocAddResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__DocAdd:
		((_tempuri__DocAdd *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDonOverResponse:
		((_tempuri__AnDonOverResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDonOver:
		((_tempuri__AnDonOver *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDonListResponse:
		((_tempuri__AnDonListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDonList:
		((_tempuri__AnDonList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDonStartResponse:
		((_tempuri__AnDonStartResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__AnDonStart:
		((_tempuri__AnDonStart *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__LineInventoryResponse:
		((_tempuri__LineInventoryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__LineInventory:
		((_tempuri__LineInventory *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__BillStateResponse:
		((_tempuri__BillStateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__BillState:
		((_tempuri__BillState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__ToolingTimesResponse:
		((_tempuri__ToolingTimesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__ToolingTimes:
		((_tempuri__ToolingTimes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__testResponse:
		((_tempuri__testResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tempuri__test:
		((_tempuri__test *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___tempuri__DocAdd_:
		soap_serialize___tempuri__DocAdd_(soap, (const struct __tempuri__DocAdd_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDonOver_:
		soap_serialize___tempuri__AnDonOver_(soap, (const struct __tempuri__AnDonOver_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDonList_:
		soap_serialize___tempuri__AnDonList_(soap, (const struct __tempuri__AnDonList_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDonStart_:
		soap_serialize___tempuri__AnDonStart_(soap, (const struct __tempuri__AnDonStart_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__LineInventory_:
		soap_serialize___tempuri__LineInventory_(soap, (const struct __tempuri__LineInventory_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__BillState_:
		soap_serialize___tempuri__BillState_(soap, (const struct __tempuri__BillState_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__ToolingTimes_:
		soap_serialize___tempuri__ToolingTimes_(soap, (const struct __tempuri__ToolingTimes_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__test_:
		soap_serialize___tempuri__test_(soap, (const struct __tempuri__test_ *)ptr);
		break;
	case SOAP_TYPE___tempuri__DocAdd:
		soap_serialize___tempuri__DocAdd(soap, (const struct __tempuri__DocAdd *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDonOver:
		soap_serialize___tempuri__AnDonOver(soap, (const struct __tempuri__AnDonOver *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDonList:
		soap_serialize___tempuri__AnDonList(soap, (const struct __tempuri__AnDonList *)ptr);
		break;
	case SOAP_TYPE___tempuri__AnDonStart:
		soap_serialize___tempuri__AnDonStart(soap, (const struct __tempuri__AnDonStart *)ptr);
		break;
	case SOAP_TYPE___tempuri__LineInventory:
		soap_serialize___tempuri__LineInventory(soap, (const struct __tempuri__LineInventory *)ptr);
		break;
	case SOAP_TYPE___tempuri__BillState:
		soap_serialize___tempuri__BillState(soap, (const struct __tempuri__BillState *)ptr);
		break;
	case SOAP_TYPE___tempuri__ToolingTimes:
		soap_serialize___tempuri__ToolingTimes(soap, (const struct __tempuri__ToolingTimes *)ptr);
		break;
	case SOAP_TYPE___tempuri__test:
		soap_serialize___tempuri__test(soap, (const struct __tempuri__test *)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__DocAdd:
		soap_serialize_PointerTo_tempuri__DocAdd(soap, (_tempuri__DocAdd *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__AnDonOver:
		soap_serialize_PointerTo_tempuri__AnDonOver(soap, (_tempuri__AnDonOver *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__AnDonList:
		soap_serialize_PointerTo_tempuri__AnDonList(soap, (_tempuri__AnDonList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__AnDonStart:
		soap_serialize_PointerTo_tempuri__AnDonStart(soap, (_tempuri__AnDonStart *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__LineInventory:
		soap_serialize_PointerTo_tempuri__LineInventory(soap, (_tempuri__LineInventory *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__BillState:
		soap_serialize_PointerTo_tempuri__BillState(soap, (_tempuri__BillState *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__ToolingTimes:
		soap_serialize_PointerTo_tempuri__ToolingTimes(soap, (_tempuri__ToolingTimes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tempuri__test:
		soap_serialize_PointerTo_tempuri__test(soap, (_tempuri__test *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE__tempuri__test:
		return (void*)soap_instantiate__tempuri__test(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__testResponse:
		return (void*)soap_instantiate__tempuri__testResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__ToolingTimes:
		return (void*)soap_instantiate__tempuri__ToolingTimes(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__ToolingTimesResponse:
		return (void*)soap_instantiate__tempuri__ToolingTimesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__BillState:
		return (void*)soap_instantiate__tempuri__BillState(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__BillStateResponse:
		return (void*)soap_instantiate__tempuri__BillStateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__LineInventory:
		return (void*)soap_instantiate__tempuri__LineInventory(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__LineInventoryResponse:
		return (void*)soap_instantiate__tempuri__LineInventoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDonStart:
		return (void*)soap_instantiate__tempuri__AnDonStart(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDonStartResponse:
		return (void*)soap_instantiate__tempuri__AnDonStartResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDonList:
		return (void*)soap_instantiate__tempuri__AnDonList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDonListResponse:
		return (void*)soap_instantiate__tempuri__AnDonListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDonOver:
		return (void*)soap_instantiate__tempuri__AnDonOver(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__AnDonOverResponse:
		return (void*)soap_instantiate__tempuri__AnDonOverResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__DocAdd:
		return (void*)soap_instantiate__tempuri__DocAdd(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tempuri__DocAddResponse:
		return (void*)soap_instantiate__tempuri__DocAddResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__test:
		return (void*)soap_instantiate___tempuri__test(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__ToolingTimes:
		return (void*)soap_instantiate___tempuri__ToolingTimes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__BillState:
		return (void*)soap_instantiate___tempuri__BillState(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__LineInventory:
		return (void*)soap_instantiate___tempuri__LineInventory(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDonStart:
		return (void*)soap_instantiate___tempuri__AnDonStart(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDonList:
		return (void*)soap_instantiate___tempuri__AnDonList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDonOver:
		return (void*)soap_instantiate___tempuri__AnDonOver(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__DocAdd:
		return (void*)soap_instantiate___tempuri__DocAdd(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__test_:
		return (void*)soap_instantiate___tempuri__test_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__ToolingTimes_:
		return (void*)soap_instantiate___tempuri__ToolingTimes_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__BillState_:
		return (void*)soap_instantiate___tempuri__BillState_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__LineInventory_:
		return (void*)soap_instantiate___tempuri__LineInventory_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDonStart_:
		return (void*)soap_instantiate___tempuri__AnDonStart_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDonList_:
		return (void*)soap_instantiate___tempuri__AnDonList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__AnDonOver_:
		return (void*)soap_instantiate___tempuri__AnDonOver_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tempuri__DocAdd_:
		return (void*)soap_instantiate___tempuri__DocAdd_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE__tempuri__test:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__test*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__test*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__testResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__testResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__testResponse*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__ToolingTimes:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__ToolingTimes*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__ToolingTimes*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__ToolingTimesResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__ToolingTimesResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__ToolingTimesResponse*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__BillState:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__BillState*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__BillState*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__BillStateResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__BillStateResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__BillStateResponse*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__LineInventory:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__LineInventory*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__LineInventory*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__LineInventoryResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__LineInventoryResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__LineInventoryResponse*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__AnDonStart:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__AnDonStart*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__AnDonStart*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__AnDonStartResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__AnDonStartResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__AnDonStartResponse*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__AnDonList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__AnDonList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__AnDonList*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__AnDonListResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__AnDonListResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__AnDonListResponse*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__AnDonOver:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__AnDonOver*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__AnDonOver*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__AnDonOverResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__AnDonOverResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__AnDonOverResponse*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__DocAdd:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__DocAdd*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__DocAdd*>(p->ptr));
		break;
	case SOAP_TYPE__tempuri__DocAddResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_tempuri__DocAddResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_tempuri__DocAddResponse*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__test:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__test*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__test*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__ToolingTimes:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__ToolingTimes*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__ToolingTimes*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__BillState:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__BillState*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__BillState*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__LineInventory:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__LineInventory*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__LineInventory*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__AnDonStart:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__AnDonStart*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__AnDonStart*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__AnDonList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__AnDonList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__AnDonList*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__AnDonOver:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__AnDonOver*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__AnDonOver*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__DocAdd:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__DocAdd*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__DocAdd*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__test_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__test_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__test_*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__ToolingTimes_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__ToolingTimes_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__ToolingTimes_*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__BillState_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__BillState_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__BillState_*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__LineInventory_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__LineInventory_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__LineInventory_*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__AnDonStart_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__AnDonStart_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__AnDonStart_*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__AnDonList_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__AnDonList_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__AnDonList_*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__AnDonOver_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__AnDonOver_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__AnDonOver_*>(p->ptr));
		break;
	case SOAP_TYPE___tempuri__DocAdd_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __tempuri__DocAdd_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __tempuri__DocAdd_*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		break;
#endif
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE__tempuri__test:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__test type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__test*)p = *(_tempuri__test*)q;
		break;
	case SOAP_TYPE__tempuri__testResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__testResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__testResponse*)p = *(_tempuri__testResponse*)q;
		break;
	case SOAP_TYPE__tempuri__ToolingTimes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__ToolingTimes type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__ToolingTimes*)p = *(_tempuri__ToolingTimes*)q;
		break;
	case SOAP_TYPE__tempuri__ToolingTimesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__ToolingTimesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__ToolingTimesResponse*)p = *(_tempuri__ToolingTimesResponse*)q;
		break;
	case SOAP_TYPE__tempuri__BillState:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__BillState type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__BillState*)p = *(_tempuri__BillState*)q;
		break;
	case SOAP_TYPE__tempuri__BillStateResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__BillStateResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__BillStateResponse*)p = *(_tempuri__BillStateResponse*)q;
		break;
	case SOAP_TYPE__tempuri__LineInventory:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__LineInventory type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__LineInventory*)p = *(_tempuri__LineInventory*)q;
		break;
	case SOAP_TYPE__tempuri__LineInventoryResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__LineInventoryResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__LineInventoryResponse*)p = *(_tempuri__LineInventoryResponse*)q;
		break;
	case SOAP_TYPE__tempuri__AnDonStart:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDonStart type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDonStart*)p = *(_tempuri__AnDonStart*)q;
		break;
	case SOAP_TYPE__tempuri__AnDonStartResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDonStartResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDonStartResponse*)p = *(_tempuri__AnDonStartResponse*)q;
		break;
	case SOAP_TYPE__tempuri__AnDonList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDonList type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDonList*)p = *(_tempuri__AnDonList*)q;
		break;
	case SOAP_TYPE__tempuri__AnDonListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDonListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDonListResponse*)p = *(_tempuri__AnDonListResponse*)q;
		break;
	case SOAP_TYPE__tempuri__AnDonOver:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDonOver type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDonOver*)p = *(_tempuri__AnDonOver*)q;
		break;
	case SOAP_TYPE__tempuri__AnDonOverResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__AnDonOverResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__AnDonOverResponse*)p = *(_tempuri__AnDonOverResponse*)q;
		break;
	case SOAP_TYPE__tempuri__DocAdd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__DocAdd type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__DocAdd*)p = *(_tempuri__DocAdd*)q;
		break;
	case SOAP_TYPE__tempuri__DocAddResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tempuri__DocAddResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tempuri__DocAddResponse*)p = *(_tempuri__DocAddResponse*)q;
		break;
	case SOAP_TYPE___tempuri__test:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__test type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__test*)p = *(struct __tempuri__test*)q;
		break;
	case SOAP_TYPE___tempuri__ToolingTimes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__ToolingTimes type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__ToolingTimes*)p = *(struct __tempuri__ToolingTimes*)q;
		break;
	case SOAP_TYPE___tempuri__BillState:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__BillState type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__BillState*)p = *(struct __tempuri__BillState*)q;
		break;
	case SOAP_TYPE___tempuri__LineInventory:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__LineInventory type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__LineInventory*)p = *(struct __tempuri__LineInventory*)q;
		break;
	case SOAP_TYPE___tempuri__AnDonStart:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDonStart type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDonStart*)p = *(struct __tempuri__AnDonStart*)q;
		break;
	case SOAP_TYPE___tempuri__AnDonList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDonList type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDonList*)p = *(struct __tempuri__AnDonList*)q;
		break;
	case SOAP_TYPE___tempuri__AnDonOver:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDonOver type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDonOver*)p = *(struct __tempuri__AnDonOver*)q;
		break;
	case SOAP_TYPE___tempuri__DocAdd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__DocAdd type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__DocAdd*)p = *(struct __tempuri__DocAdd*)q;
		break;
	case SOAP_TYPE___tempuri__test_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__test_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__test_*)p = *(struct __tempuri__test_*)q;
		break;
	case SOAP_TYPE___tempuri__ToolingTimes_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__ToolingTimes_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__ToolingTimes_*)p = *(struct __tempuri__ToolingTimes_*)q;
		break;
	case SOAP_TYPE___tempuri__BillState_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__BillState_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__BillState_*)p = *(struct __tempuri__BillState_*)q;
		break;
	case SOAP_TYPE___tempuri__LineInventory_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__LineInventory_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__LineInventory_*)p = *(struct __tempuri__LineInventory_*)q;
		break;
	case SOAP_TYPE___tempuri__AnDonStart_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDonStart_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDonStart_*)p = *(struct __tempuri__AnDonStart_*)q;
		break;
	case SOAP_TYPE___tempuri__AnDonList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDonList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDonList_*)p = *(struct __tempuri__AnDonList_*)q;
		break;
	case SOAP_TYPE___tempuri__AnDonOver_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__AnDonOver_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__AnDonOver_*)p = *(struct __tempuri__AnDonOver_*)q;
		break;
	case SOAP_TYPE___tempuri__DocAdd_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tempuri__DocAdd_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __tempuri__DocAdd_*)p = *(struct __tempuri__DocAdd_*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__DocAddResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__DocAddResponse::DocAddResult);
	/* transient soap skipped */
}

void _tempuri__DocAddResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__DocAddResponse::DocAddResult);
#endif
}

int _tempuri__DocAddResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__DocAddResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__DocAddResponse(struct soap *soap, const char *tag, int id, const _tempuri__DocAddResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__DocAddResponse), type))
		return soap->error;
	if (a->DocAddResult)
		soap_element_result(soap, "tempuri:DocAddResult");
	if (soap_out_string(soap, "tempuri:DocAddResult", -1, (char*const*)&a->_tempuri__DocAddResponse::DocAddResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__DocAddResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__DocAddResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__DocAddResponse * SOAP_FMAC4 soap_in__tempuri__DocAddResponse(struct soap *soap, const char *tag, _tempuri__DocAddResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__DocAddResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__DocAddResponse, sizeof(_tempuri__DocAddResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__DocAddResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__DocAddResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DocAddResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DocAddResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:DocAddResult", (char**)&a->_tempuri__DocAddResponse::DocAddResult, "xsd:string"))
				{	soap_flag_DocAddResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:DocAddResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__DocAddResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__DocAddResponse, SOAP_TYPE__tempuri__DocAddResponse, sizeof(_tempuri__DocAddResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__DocAddResponse * SOAP_FMAC2 soap_instantiate__tempuri__DocAddResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__DocAddResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__DocAddResponse *p;
	size_t k = sizeof(_tempuri__DocAddResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__DocAddResponse);
		if (p)
			((_tempuri__DocAddResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__DocAddResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__DocAddResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__DocAddResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__DocAddResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__DocAddResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__DocAddResponse(soap, tag ? tag : "tempuri:DocAddResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__DocAddResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__DocAddResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__DocAddResponse * SOAP_FMAC4 soap_get__tempuri__DocAddResponse(struct soap *soap, _tempuri__DocAddResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__DocAddResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__DocAdd::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__DocAdd::DocTypeCode);
	soap_default_string(soap, &this->_tempuri__DocAdd::DocXml);
	/* transient soap skipped */
}

void _tempuri__DocAdd::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__DocAdd::DocTypeCode);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__DocAdd::DocXml);
#endif
}

int _tempuri__DocAdd::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__DocAdd(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__DocAdd(struct soap *soap, const char *tag, int id, const _tempuri__DocAdd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__DocAdd), type))
		return soap->error;
	if (soap_out_string(soap, "tempuri:DocTypeCode", -1, (char*const*)&a->_tempuri__DocAdd::DocTypeCode, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:DocXml", -1, (char*const*)&a->_tempuri__DocAdd::DocXml, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__DocAdd::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__DocAdd(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__DocAdd * SOAP_FMAC4 soap_in__tempuri__DocAdd(struct soap *soap, const char *tag, _tempuri__DocAdd *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__DocAdd *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__DocAdd, sizeof(_tempuri__DocAdd), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__DocAdd)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__DocAdd *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DocTypeCode1 = 1;
	size_t soap_flag_DocXml1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DocTypeCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:DocTypeCode", (char**)&a->_tempuri__DocAdd::DocTypeCode, "xsd:string"))
				{	soap_flag_DocTypeCode1--;
					continue;
				}
			}
			if (soap_flag_DocXml1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:DocXml", (char**)&a->_tempuri__DocAdd::DocXml, "xsd:string"))
				{	soap_flag_DocXml1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__DocAdd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__DocAdd, SOAP_TYPE__tempuri__DocAdd, sizeof(_tempuri__DocAdd), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__DocAdd * SOAP_FMAC2 soap_instantiate__tempuri__DocAdd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__DocAdd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__DocAdd *p;
	size_t k = sizeof(_tempuri__DocAdd);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__DocAdd);
		if (p)
			((_tempuri__DocAdd*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__DocAdd, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__DocAdd*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__DocAdd location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__DocAdd, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__DocAdd::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__DocAdd(soap, tag ? tag : "tempuri:DocAdd", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__DocAdd::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__DocAdd(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__DocAdd * SOAP_FMAC4 soap_get__tempuri__DocAdd(struct soap *soap, _tempuri__DocAdd *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__DocAdd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDonOverResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__AnDonOverResponse::AnDonOverResult);
	/* transient soap skipped */
}

void _tempuri__AnDonOverResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__AnDonOverResponse::AnDonOverResult);
#endif
}

int _tempuri__AnDonOverResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDonOverResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDonOverResponse(struct soap *soap, const char *tag, int id, const _tempuri__AnDonOverResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDonOverResponse), type))
		return soap->error;
	if (a->AnDonOverResult)
		soap_element_result(soap, "tempuri:AnDonOverResult");
	if (soap_out_string(soap, "tempuri:AnDonOverResult", -1, (char*const*)&a->_tempuri__AnDonOverResponse::AnDonOverResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDonOverResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDonOverResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDonOverResponse * SOAP_FMAC4 soap_in__tempuri__AnDonOverResponse(struct soap *soap, const char *tag, _tempuri__AnDonOverResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDonOverResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDonOverResponse, sizeof(_tempuri__AnDonOverResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDonOverResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDonOverResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AnDonOverResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AnDonOverResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:AnDonOverResult", (char**)&a->_tempuri__AnDonOverResponse::AnDonOverResult, "xsd:string"))
				{	soap_flag_AnDonOverResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:AnDonOverResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AnDonOverResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDonOverResponse, SOAP_TYPE__tempuri__AnDonOverResponse, sizeof(_tempuri__AnDonOverResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDonOverResponse * SOAP_FMAC2 soap_instantiate__tempuri__AnDonOverResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDonOverResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDonOverResponse *p;
	size_t k = sizeof(_tempuri__AnDonOverResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__AnDonOverResponse);
		if (p)
			((_tempuri__AnDonOverResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__AnDonOverResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__AnDonOverResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDonOverResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__AnDonOverResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__AnDonOverResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDonOverResponse(soap, tag ? tag : "tempuri:AnDonOverResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDonOverResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDonOverResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDonOverResponse * SOAP_FMAC4 soap_get__tempuri__AnDonOverResponse(struct soap *soap, _tempuri__AnDonOverResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDonOverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDonOver::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__AnDonOver::AnDonCode);
	soap_default_string(soap, &this->_tempuri__AnDonOver::HandleUser);
	soap_default_string(soap, &this->_tempuri__AnDonOver::HandleRemark);
	soap_default_string(soap, &this->_tempuri__AnDonOver::HandleTime);
	soap_default_string(soap, &this->_tempuri__AnDonOver::State);
	/* transient soap skipped */
}

void _tempuri__AnDonOver::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__AnDonOver::AnDonCode);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__AnDonOver::HandleUser);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__AnDonOver::HandleRemark);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__AnDonOver::HandleTime);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__AnDonOver::State);
#endif
}

int _tempuri__AnDonOver::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDonOver(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDonOver(struct soap *soap, const char *tag, int id, const _tempuri__AnDonOver *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDonOver), type))
		return soap->error;
	if (soap_out_string(soap, "tempuri:AnDonCode", -1, (char*const*)&a->_tempuri__AnDonOver::AnDonCode, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:HandleUser", -1, (char*const*)&a->_tempuri__AnDonOver::HandleUser, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:HandleRemark", -1, (char*const*)&a->_tempuri__AnDonOver::HandleRemark, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:HandleTime", -1, (char*const*)&a->_tempuri__AnDonOver::HandleTime, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:State", -1, (char*const*)&a->_tempuri__AnDonOver::State, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDonOver::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDonOver(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDonOver * SOAP_FMAC4 soap_in__tempuri__AnDonOver(struct soap *soap, const char *tag, _tempuri__AnDonOver *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDonOver *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDonOver, sizeof(_tempuri__AnDonOver), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDonOver)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDonOver *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AnDonCode1 = 1;
	size_t soap_flag_HandleUser1 = 1;
	size_t soap_flag_HandleRemark1 = 1;
	size_t soap_flag_HandleTime1 = 1;
	size_t soap_flag_State1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AnDonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:AnDonCode", (char**)&a->_tempuri__AnDonOver::AnDonCode, "xsd:string"))
				{	soap_flag_AnDonCode1--;
					continue;
				}
			}
			if (soap_flag_HandleUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:HandleUser", (char**)&a->_tempuri__AnDonOver::HandleUser, "xsd:string"))
				{	soap_flag_HandleUser1--;
					continue;
				}
			}
			if (soap_flag_HandleRemark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:HandleRemark", (char**)&a->_tempuri__AnDonOver::HandleRemark, "xsd:string"))
				{	soap_flag_HandleRemark1--;
					continue;
				}
			}
			if (soap_flag_HandleTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:HandleTime", (char**)&a->_tempuri__AnDonOver::HandleTime, "xsd:string"))
				{	soap_flag_HandleTime1--;
					continue;
				}
			}
			if (soap_flag_State1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:State", (char**)&a->_tempuri__AnDonOver::State, "xsd:string"))
				{	soap_flag_State1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AnDonOver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDonOver, SOAP_TYPE__tempuri__AnDonOver, sizeof(_tempuri__AnDonOver), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDonOver * SOAP_FMAC2 soap_instantiate__tempuri__AnDonOver(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDonOver(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDonOver *p;
	size_t k = sizeof(_tempuri__AnDonOver);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__AnDonOver);
		if (p)
			((_tempuri__AnDonOver*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__AnDonOver, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__AnDonOver*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDonOver location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__AnDonOver, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__AnDonOver::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDonOver(soap, tag ? tag : "tempuri:AnDonOver", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDonOver::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDonOver(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDonOver * SOAP_FMAC4 soap_get__tempuri__AnDonOver(struct soap *soap, _tempuri__AnDonOver *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDonOver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDonListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__AnDonListResponse::AnDonListResult);
	/* transient soap skipped */
}

void _tempuri__AnDonListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__AnDonListResponse::AnDonListResult);
#endif
}

int _tempuri__AnDonListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDonListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDonListResponse(struct soap *soap, const char *tag, int id, const _tempuri__AnDonListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDonListResponse), type))
		return soap->error;
	if (a->AnDonListResult)
		soap_element_result(soap, "tempuri:AnDonListResult");
	if (soap_out_string(soap, "tempuri:AnDonListResult", -1, (char*const*)&a->_tempuri__AnDonListResponse::AnDonListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDonListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDonListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDonListResponse * SOAP_FMAC4 soap_in__tempuri__AnDonListResponse(struct soap *soap, const char *tag, _tempuri__AnDonListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDonListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDonListResponse, sizeof(_tempuri__AnDonListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDonListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDonListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AnDonListResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AnDonListResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:AnDonListResult", (char**)&a->_tempuri__AnDonListResponse::AnDonListResult, "xsd:string"))
				{	soap_flag_AnDonListResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:AnDonListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AnDonListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDonListResponse, SOAP_TYPE__tempuri__AnDonListResponse, sizeof(_tempuri__AnDonListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDonListResponse * SOAP_FMAC2 soap_instantiate__tempuri__AnDonListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDonListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDonListResponse *p;
	size_t k = sizeof(_tempuri__AnDonListResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__AnDonListResponse);
		if (p)
			((_tempuri__AnDonListResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__AnDonListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__AnDonListResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDonListResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__AnDonListResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__AnDonListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDonListResponse(soap, tag ? tag : "tempuri:AnDonListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDonListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDonListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDonListResponse * SOAP_FMAC4 soap_get__tempuri__AnDonListResponse(struct soap *soap, _tempuri__AnDonListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDonListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDonList::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tempuri__AnDonList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__AnDonList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDonList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDonList(struct soap *soap, const char *tag, int id, const _tempuri__AnDonList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDonList), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDonList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDonList(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDonList * SOAP_FMAC4 soap_in__tempuri__AnDonList(struct soap *soap, const char *tag, _tempuri__AnDonList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDonList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDonList, sizeof(_tempuri__AnDonList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDonList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDonList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AnDonList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDonList, SOAP_TYPE__tempuri__AnDonList, sizeof(_tempuri__AnDonList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDonList * SOAP_FMAC2 soap_instantiate__tempuri__AnDonList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDonList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDonList *p;
	size_t k = sizeof(_tempuri__AnDonList);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__AnDonList);
		if (p)
			((_tempuri__AnDonList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__AnDonList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__AnDonList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDonList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__AnDonList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__AnDonList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDonList(soap, tag ? tag : "tempuri:AnDonList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDonList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDonList(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDonList * SOAP_FMAC4 soap_get__tempuri__AnDonList(struct soap *soap, _tempuri__AnDonList *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDonList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDonStartResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__AnDonStartResponse::AnDonStartResult);
	/* transient soap skipped */
}

void _tempuri__AnDonStartResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__AnDonStartResponse::AnDonStartResult);
#endif
}

int _tempuri__AnDonStartResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDonStartResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDonStartResponse(struct soap *soap, const char *tag, int id, const _tempuri__AnDonStartResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDonStartResponse), type))
		return soap->error;
	if (a->AnDonStartResult)
		soap_element_result(soap, "tempuri:AnDonStartResult");
	if (soap_out_string(soap, "tempuri:AnDonStartResult", -1, (char*const*)&a->_tempuri__AnDonStartResponse::AnDonStartResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDonStartResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDonStartResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDonStartResponse * SOAP_FMAC4 soap_in__tempuri__AnDonStartResponse(struct soap *soap, const char *tag, _tempuri__AnDonStartResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDonStartResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDonStartResponse, sizeof(_tempuri__AnDonStartResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDonStartResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDonStartResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AnDonStartResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AnDonStartResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:AnDonStartResult", (char**)&a->_tempuri__AnDonStartResponse::AnDonStartResult, "xsd:string"))
				{	soap_flag_AnDonStartResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:AnDonStartResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AnDonStartResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDonStartResponse, SOAP_TYPE__tempuri__AnDonStartResponse, sizeof(_tempuri__AnDonStartResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDonStartResponse * SOAP_FMAC2 soap_instantiate__tempuri__AnDonStartResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDonStartResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDonStartResponse *p;
	size_t k = sizeof(_tempuri__AnDonStartResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__AnDonStartResponse);
		if (p)
			((_tempuri__AnDonStartResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__AnDonStartResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__AnDonStartResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDonStartResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__AnDonStartResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__AnDonStartResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDonStartResponse(soap, tag ? tag : "tempuri:AnDonStartResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDonStartResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDonStartResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDonStartResponse * SOAP_FMAC4 soap_get__tempuri__AnDonStartResponse(struct soap *soap, _tempuri__AnDonStartResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDonStartResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__AnDonStart::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__AnDonStart::CallTypeCode);
	soap_default_string(soap, &this->_tempuri__AnDonStart::Remark);
	soap_default_string(soap, &this->_tempuri__AnDonStart::WorkLineCode);
	soap_default_string(soap, &this->_tempuri__AnDonStart::WorkStationCode);
	soap_default_string(soap, &this->_tempuri__AnDonStart::UserCode);
	/* transient soap skipped */
}

void _tempuri__AnDonStart::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__AnDonStart::CallTypeCode);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__AnDonStart::Remark);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__AnDonStart::WorkLineCode);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__AnDonStart::WorkStationCode);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__AnDonStart::UserCode);
#endif
}

int _tempuri__AnDonStart::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__AnDonStart(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__AnDonStart(struct soap *soap, const char *tag, int id, const _tempuri__AnDonStart *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__AnDonStart), type))
		return soap->error;
	if (soap_out_string(soap, "tempuri:CallTypeCode", -1, (char*const*)&a->_tempuri__AnDonStart::CallTypeCode, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:Remark", -1, (char*const*)&a->_tempuri__AnDonStart::Remark, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:WorkLineCode", -1, (char*const*)&a->_tempuri__AnDonStart::WorkLineCode, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:WorkStationCode", -1, (char*const*)&a->_tempuri__AnDonStart::WorkStationCode, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:UserCode", -1, (char*const*)&a->_tempuri__AnDonStart::UserCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__AnDonStart::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__AnDonStart(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__AnDonStart * SOAP_FMAC4 soap_in__tempuri__AnDonStart(struct soap *soap, const char *tag, _tempuri__AnDonStart *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__AnDonStart *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__AnDonStart, sizeof(_tempuri__AnDonStart), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__AnDonStart)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__AnDonStart *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CallTypeCode1 = 1;
	size_t soap_flag_Remark1 = 1;
	size_t soap_flag_WorkLineCode1 = 1;
	size_t soap_flag_WorkStationCode1 = 1;
	size_t soap_flag_UserCode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CallTypeCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:CallTypeCode", (char**)&a->_tempuri__AnDonStart::CallTypeCode, "xsd:string"))
				{	soap_flag_CallTypeCode1--;
					continue;
				}
			}
			if (soap_flag_Remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:Remark", (char**)&a->_tempuri__AnDonStart::Remark, "xsd:string"))
				{	soap_flag_Remark1--;
					continue;
				}
			}
			if (soap_flag_WorkLineCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:WorkLineCode", (char**)&a->_tempuri__AnDonStart::WorkLineCode, "xsd:string"))
				{	soap_flag_WorkLineCode1--;
					continue;
				}
			}
			if (soap_flag_WorkStationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:WorkStationCode", (char**)&a->_tempuri__AnDonStart::WorkStationCode, "xsd:string"))
				{	soap_flag_WorkStationCode1--;
					continue;
				}
			}
			if (soap_flag_UserCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:UserCode", (char**)&a->_tempuri__AnDonStart::UserCode, "xsd:string"))
				{	soap_flag_UserCode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__AnDonStart *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__AnDonStart, SOAP_TYPE__tempuri__AnDonStart, sizeof(_tempuri__AnDonStart), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__AnDonStart * SOAP_FMAC2 soap_instantiate__tempuri__AnDonStart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__AnDonStart(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__AnDonStart *p;
	size_t k = sizeof(_tempuri__AnDonStart);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__AnDonStart);
		if (p)
			((_tempuri__AnDonStart*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__AnDonStart, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__AnDonStart*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__AnDonStart location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__AnDonStart, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__AnDonStart::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__AnDonStart(soap, tag ? tag : "tempuri:AnDonStart", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__AnDonStart::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__AnDonStart(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__AnDonStart * SOAP_FMAC4 soap_get__tempuri__AnDonStart(struct soap *soap, _tempuri__AnDonStart *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__AnDonStart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__LineInventoryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__LineInventoryResponse::LineInventoryResult);
	/* transient soap skipped */
}

void _tempuri__LineInventoryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__LineInventoryResponse::LineInventoryResult);
#endif
}

int _tempuri__LineInventoryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__LineInventoryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__LineInventoryResponse(struct soap *soap, const char *tag, int id, const _tempuri__LineInventoryResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__LineInventoryResponse), type))
		return soap->error;
	if (a->LineInventoryResult)
		soap_element_result(soap, "tempuri:LineInventoryResult");
	if (soap_out_string(soap, "tempuri:LineInventoryResult", -1, (char*const*)&a->_tempuri__LineInventoryResponse::LineInventoryResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__LineInventoryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__LineInventoryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__LineInventoryResponse * SOAP_FMAC4 soap_in__tempuri__LineInventoryResponse(struct soap *soap, const char *tag, _tempuri__LineInventoryResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__LineInventoryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__LineInventoryResponse, sizeof(_tempuri__LineInventoryResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__LineInventoryResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__LineInventoryResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LineInventoryResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LineInventoryResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:LineInventoryResult", (char**)&a->_tempuri__LineInventoryResponse::LineInventoryResult, "xsd:string"))
				{	soap_flag_LineInventoryResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:LineInventoryResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__LineInventoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__LineInventoryResponse, SOAP_TYPE__tempuri__LineInventoryResponse, sizeof(_tempuri__LineInventoryResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__LineInventoryResponse * SOAP_FMAC2 soap_instantiate__tempuri__LineInventoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__LineInventoryResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__LineInventoryResponse *p;
	size_t k = sizeof(_tempuri__LineInventoryResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__LineInventoryResponse);
		if (p)
			((_tempuri__LineInventoryResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__LineInventoryResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__LineInventoryResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__LineInventoryResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__LineInventoryResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__LineInventoryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__LineInventoryResponse(soap, tag ? tag : "tempuri:LineInventoryResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__LineInventoryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__LineInventoryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__LineInventoryResponse * SOAP_FMAC4 soap_get__tempuri__LineInventoryResponse(struct soap *soap, _tempuri__LineInventoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__LineInventoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__LineInventory::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__LineInventory::WorkLineCode);
	soap_default_string(soap, &this->_tempuri__LineInventory::BillCode);
	soap_default_string(soap, &this->_tempuri__LineInventory::BarCode);
	/* transient soap skipped */
}

void _tempuri__LineInventory::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__LineInventory::WorkLineCode);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__LineInventory::BillCode);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__LineInventory::BarCode);
#endif
}

int _tempuri__LineInventory::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__LineInventory(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__LineInventory(struct soap *soap, const char *tag, int id, const _tempuri__LineInventory *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__LineInventory), type))
		return soap->error;
	if (soap_out_string(soap, "tempuri:WorkLineCode", -1, (char*const*)&a->_tempuri__LineInventory::WorkLineCode, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:BillCode", -1, (char*const*)&a->_tempuri__LineInventory::BillCode, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:BarCode", -1, (char*const*)&a->_tempuri__LineInventory::BarCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__LineInventory::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__LineInventory(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__LineInventory * SOAP_FMAC4 soap_in__tempuri__LineInventory(struct soap *soap, const char *tag, _tempuri__LineInventory *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__LineInventory *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__LineInventory, sizeof(_tempuri__LineInventory), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__LineInventory)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__LineInventory *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_WorkLineCode1 = 1;
	size_t soap_flag_BillCode1 = 1;
	size_t soap_flag_BarCode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WorkLineCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:WorkLineCode", (char**)&a->_tempuri__LineInventory::WorkLineCode, "xsd:string"))
				{	soap_flag_WorkLineCode1--;
					continue;
				}
			}
			if (soap_flag_BillCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:BillCode", (char**)&a->_tempuri__LineInventory::BillCode, "xsd:string"))
				{	soap_flag_BillCode1--;
					continue;
				}
			}
			if (soap_flag_BarCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:BarCode", (char**)&a->_tempuri__LineInventory::BarCode, "xsd:string"))
				{	soap_flag_BarCode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__LineInventory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__LineInventory, SOAP_TYPE__tempuri__LineInventory, sizeof(_tempuri__LineInventory), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__LineInventory * SOAP_FMAC2 soap_instantiate__tempuri__LineInventory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__LineInventory(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__LineInventory *p;
	size_t k = sizeof(_tempuri__LineInventory);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__LineInventory);
		if (p)
			((_tempuri__LineInventory*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__LineInventory, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__LineInventory*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__LineInventory location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__LineInventory, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__LineInventory::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__LineInventory(soap, tag ? tag : "tempuri:LineInventory", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__LineInventory::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__LineInventory(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__LineInventory * SOAP_FMAC4 soap_get__tempuri__LineInventory(struct soap *soap, _tempuri__LineInventory *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__LineInventory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__BillStateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__BillStateResponse::BillStateResult);
	/* transient soap skipped */
}

void _tempuri__BillStateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__BillStateResponse::BillStateResult);
#endif
}

int _tempuri__BillStateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__BillStateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__BillStateResponse(struct soap *soap, const char *tag, int id, const _tempuri__BillStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__BillStateResponse), type))
		return soap->error;
	if (a->BillStateResult)
		soap_element_result(soap, "tempuri:BillStateResult");
	if (soap_out_string(soap, "tempuri:BillStateResult", -1, (char*const*)&a->_tempuri__BillStateResponse::BillStateResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__BillStateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__BillStateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__BillStateResponse * SOAP_FMAC4 soap_in__tempuri__BillStateResponse(struct soap *soap, const char *tag, _tempuri__BillStateResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__BillStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__BillStateResponse, sizeof(_tempuri__BillStateResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__BillStateResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__BillStateResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BillStateResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BillStateResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:BillStateResult", (char**)&a->_tempuri__BillStateResponse::BillStateResult, "xsd:string"))
				{	soap_flag_BillStateResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:BillStateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__BillStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__BillStateResponse, SOAP_TYPE__tempuri__BillStateResponse, sizeof(_tempuri__BillStateResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__BillStateResponse * SOAP_FMAC2 soap_instantiate__tempuri__BillStateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__BillStateResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__BillStateResponse *p;
	size_t k = sizeof(_tempuri__BillStateResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__BillStateResponse);
		if (p)
			((_tempuri__BillStateResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__BillStateResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__BillStateResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__BillStateResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__BillStateResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__BillStateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__BillStateResponse(soap, tag ? tag : "tempuri:BillStateResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__BillStateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__BillStateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__BillStateResponse * SOAP_FMAC4 soap_get__tempuri__BillStateResponse(struct soap *soap, _tempuri__BillStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__BillStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__BillState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__BillState::BillCode);
	soap_default_int(soap, &this->_tempuri__BillState::OverTotal);
	soap_default_string(soap, &this->_tempuri__BillState::OverTime);
	soap_default_int(soap, &this->_tempuri__BillState::State);
	/* transient soap skipped */
}

void _tempuri__BillState::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__BillState::BillCode);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__BillState::OverTime);
#endif
}

int _tempuri__BillState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__BillState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__BillState(struct soap *soap, const char *tag, int id, const _tempuri__BillState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__BillState), type))
		return soap->error;
	if (soap_out_string(soap, "tempuri:BillCode", -1, (char*const*)&a->_tempuri__BillState::BillCode, ""))
		return soap->error;
	if (soap_out_int(soap, "tempuri:OverTotal", -1, &a->_tempuri__BillState::OverTotal, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:OverTime", -1, (char*const*)&a->_tempuri__BillState::OverTime, ""))
		return soap->error;
	if (soap_out_int(soap, "tempuri:State", -1, &a->_tempuri__BillState::State, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__BillState::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__BillState(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__BillState * SOAP_FMAC4 soap_in__tempuri__BillState(struct soap *soap, const char *tag, _tempuri__BillState *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__BillState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__BillState, sizeof(_tempuri__BillState), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__BillState)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__BillState *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BillCode1 = 1;
	size_t soap_flag_OverTotal1 = 1;
	size_t soap_flag_OverTime1 = 1;
	size_t soap_flag_State1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BillCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:BillCode", (char**)&a->_tempuri__BillState::BillCode, "xsd:string"))
				{	soap_flag_BillCode1--;
					continue;
				}
			}
			if (soap_flag_OverTotal1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tempuri:OverTotal", &a->_tempuri__BillState::OverTotal, "xsd:int"))
				{	soap_flag_OverTotal1--;
					continue;
				}
			}
			if (soap_flag_OverTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:OverTime", (char**)&a->_tempuri__BillState::OverTime, "xsd:string"))
				{	soap_flag_OverTime1--;
					continue;
				}
			}
			if (soap_flag_State1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tempuri:State", &a->_tempuri__BillState::State, "xsd:int"))
				{	soap_flag_State1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OverTotal1 > 0 || soap_flag_State1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tempuri__BillState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__BillState, SOAP_TYPE__tempuri__BillState, sizeof(_tempuri__BillState), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__BillState * SOAP_FMAC2 soap_instantiate__tempuri__BillState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__BillState(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__BillState *p;
	size_t k = sizeof(_tempuri__BillState);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__BillState);
		if (p)
			((_tempuri__BillState*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__BillState, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__BillState*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__BillState location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__BillState, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__BillState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__BillState(soap, tag ? tag : "tempuri:BillState", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__BillState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__BillState(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__BillState * SOAP_FMAC4 soap_get__tempuri__BillState(struct soap *soap, _tempuri__BillState *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__BillState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__ToolingTimesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__ToolingTimesResponse::ToolingTimesResult);
	/* transient soap skipped */
}

void _tempuri__ToolingTimesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__ToolingTimesResponse::ToolingTimesResult);
#endif
}

int _tempuri__ToolingTimesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__ToolingTimesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__ToolingTimesResponse(struct soap *soap, const char *tag, int id, const _tempuri__ToolingTimesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__ToolingTimesResponse), type))
		return soap->error;
	if (a->ToolingTimesResult)
		soap_element_result(soap, "tempuri:ToolingTimesResult");
	if (soap_out_string(soap, "tempuri:ToolingTimesResult", -1, (char*const*)&a->_tempuri__ToolingTimesResponse::ToolingTimesResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__ToolingTimesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__ToolingTimesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__ToolingTimesResponse * SOAP_FMAC4 soap_in__tempuri__ToolingTimesResponse(struct soap *soap, const char *tag, _tempuri__ToolingTimesResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__ToolingTimesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__ToolingTimesResponse, sizeof(_tempuri__ToolingTimesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__ToolingTimesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__ToolingTimesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ToolingTimesResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ToolingTimesResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:ToolingTimesResult", (char**)&a->_tempuri__ToolingTimesResponse::ToolingTimesResult, "xsd:string"))
				{	soap_flag_ToolingTimesResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:ToolingTimesResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__ToolingTimesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__ToolingTimesResponse, SOAP_TYPE__tempuri__ToolingTimesResponse, sizeof(_tempuri__ToolingTimesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__ToolingTimesResponse * SOAP_FMAC2 soap_instantiate__tempuri__ToolingTimesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__ToolingTimesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__ToolingTimesResponse *p;
	size_t k = sizeof(_tempuri__ToolingTimesResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__ToolingTimesResponse);
		if (p)
			((_tempuri__ToolingTimesResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__ToolingTimesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__ToolingTimesResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__ToolingTimesResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__ToolingTimesResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__ToolingTimesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__ToolingTimesResponse(soap, tag ? tag : "tempuri:ToolingTimesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__ToolingTimesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__ToolingTimesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__ToolingTimesResponse * SOAP_FMAC4 soap_get__tempuri__ToolingTimesResponse(struct soap *soap, _tempuri__ToolingTimesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__ToolingTimesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__ToolingTimes::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__ToolingTimes::BillCode);
	soap_default_string(soap, &this->_tempuri__ToolingTimes::ToolingCode);
	soap_default_int(soap, &this->_tempuri__ToolingTimes::Times);
	/* transient soap skipped */
}

void _tempuri__ToolingTimes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__ToolingTimes::BillCode);
	soap_serialize_string(soap, (char*const*)&this->_tempuri__ToolingTimes::ToolingCode);
#endif
}

int _tempuri__ToolingTimes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__ToolingTimes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__ToolingTimes(struct soap *soap, const char *tag, int id, const _tempuri__ToolingTimes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__ToolingTimes), type))
		return soap->error;
	if (soap_out_string(soap, "tempuri:BillCode", -1, (char*const*)&a->_tempuri__ToolingTimes::BillCode, ""))
		return soap->error;
	if (soap_out_string(soap, "tempuri:ToolingCode", -1, (char*const*)&a->_tempuri__ToolingTimes::ToolingCode, ""))
		return soap->error;
	if (soap_out_int(soap, "tempuri:Times", -1, &a->_tempuri__ToolingTimes::Times, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__ToolingTimes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__ToolingTimes(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__ToolingTimes * SOAP_FMAC4 soap_in__tempuri__ToolingTimes(struct soap *soap, const char *tag, _tempuri__ToolingTimes *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__ToolingTimes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__ToolingTimes, sizeof(_tempuri__ToolingTimes), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__ToolingTimes)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__ToolingTimes *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BillCode1 = 1;
	size_t soap_flag_ToolingCode1 = 1;
	size_t soap_flag_Times1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BillCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:BillCode", (char**)&a->_tempuri__ToolingTimes::BillCode, "xsd:string"))
				{	soap_flag_BillCode1--;
					continue;
				}
			}
			if (soap_flag_ToolingCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:ToolingCode", (char**)&a->_tempuri__ToolingTimes::ToolingCode, "xsd:string"))
				{	soap_flag_ToolingCode1--;
					continue;
				}
			}
			if (soap_flag_Times1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tempuri:Times", &a->_tempuri__ToolingTimes::Times, "xsd:int"))
				{	soap_flag_Times1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Times1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tempuri__ToolingTimes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__ToolingTimes, SOAP_TYPE__tempuri__ToolingTimes, sizeof(_tempuri__ToolingTimes), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__ToolingTimes * SOAP_FMAC2 soap_instantiate__tempuri__ToolingTimes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__ToolingTimes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__ToolingTimes *p;
	size_t k = sizeof(_tempuri__ToolingTimes);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__ToolingTimes);
		if (p)
			((_tempuri__ToolingTimes*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__ToolingTimes, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__ToolingTimes*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__ToolingTimes location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__ToolingTimes, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__ToolingTimes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__ToolingTimes(soap, tag ? tag : "tempuri:ToolingTimes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__ToolingTimes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__ToolingTimes(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__ToolingTimes * SOAP_FMAC4 soap_get__tempuri__ToolingTimes(struct soap *soap, _tempuri__ToolingTimes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__ToolingTimes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__testResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_tempuri__testResponse::testResult);
	/* transient soap skipped */
}

void _tempuri__testResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_tempuri__testResponse::testResult);
#endif
}

int _tempuri__testResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__testResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__testResponse(struct soap *soap, const char *tag, int id, const _tempuri__testResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__testResponse), type))
		return soap->error;
	if (a->testResult)
		soap_element_result(soap, "tempuri:testResult");
	if (soap_out_string(soap, "tempuri:testResult", -1, (char*const*)&a->_tempuri__testResponse::testResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__testResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__testResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__testResponse * SOAP_FMAC4 soap_in__tempuri__testResponse(struct soap *soap, const char *tag, _tempuri__testResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__testResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__testResponse, sizeof(_tempuri__testResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__testResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__testResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_testResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_testResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tempuri:testResult", (char**)&a->_tempuri__testResponse::testResult, "xsd:string"))
				{	soap_flag_testResult1--;
					continue;
				}
			}
			soap_check_result(soap, "tempuri:testResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tempuri__testResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__testResponse, SOAP_TYPE__tempuri__testResponse, sizeof(_tempuri__testResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__testResponse * SOAP_FMAC2 soap_instantiate__tempuri__testResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__testResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__testResponse *p;
	size_t k = sizeof(_tempuri__testResponse);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__testResponse);
		if (p)
			((_tempuri__testResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__testResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__testResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__testResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__testResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__testResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__testResponse(soap, tag ? tag : "tempuri:testResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__testResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__testResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__testResponse * SOAP_FMAC4 soap_get__tempuri__testResponse(struct soap *soap, _tempuri__testResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__testResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tempuri__test::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_tempuri__test::i);
	/* transient soap skipped */
}

void _tempuri__test::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tempuri__test::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tempuri__test(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tempuri__test(struct soap *soap, const char *tag, int id, const _tempuri__test *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tempuri__test), type))
		return soap->error;
	if (soap_out_int(soap, "tempuri:i", -1, &a->_tempuri__test::i, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tempuri__test::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tempuri__test(soap, tag, this, type);
}

SOAP_FMAC3 _tempuri__test * SOAP_FMAC4 soap_in__tempuri__test(struct soap *soap, const char *tag, _tempuri__test *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tempuri__test *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tempuri__test, sizeof(_tempuri__test), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tempuri__test)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tempuri__test *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_i1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_i1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tempuri:i", &a->_tempuri__test::i, "xsd:int"))
				{	soap_flag_i1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_i1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tempuri__test *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tempuri__test, SOAP_TYPE__tempuri__test, sizeof(_tempuri__test), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tempuri__test * SOAP_FMAC2 soap_instantiate__tempuri__test(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tempuri__test(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tempuri__test *p;
	size_t k = sizeof(_tempuri__test);
	if (n < 0)
	{	p = SOAP_NEW(_tempuri__test);
		if (p)
			((_tempuri__test*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_tempuri__test, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_tempuri__test*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tempuri__test location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__tempuri__test, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _tempuri__test::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tempuri__test(soap, tag ? tag : "tempuri:test", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tempuri__test::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tempuri__test(soap, this, tag, type);
}

SOAP_FMAC3 _tempuri__test * SOAP_FMAC4 soap_get__tempuri__test(struct soap *soap, _tempuri__test *p, const char *tag, const char *type)
{
	if ((p = soap_in__tempuri__test(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__DocAdd_(struct soap *soap, struct __tempuri__DocAdd_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__DocAdd = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__DocAdd_(struct soap *soap, const struct __tempuri__DocAdd_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__DocAdd(soap, &a->tempuri__DocAdd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__DocAdd_(struct soap *soap, const char *tag, int id, const struct __tempuri__DocAdd_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__DocAdd(soap, "tempuri:DocAdd", -1, &a->tempuri__DocAdd, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__DocAdd_ * SOAP_FMAC4 soap_in___tempuri__DocAdd_(struct soap *soap, const char *tag, struct __tempuri__DocAdd_ *a, const char *type)
{
	size_t soap_flag_tempuri__DocAdd = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__DocAdd_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__DocAdd_, sizeof(struct __tempuri__DocAdd_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__DocAdd_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__DocAdd && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__DocAdd(soap, "tempuri:DocAdd", &a->tempuri__DocAdd, ""))
				{	soap_flag_tempuri__DocAdd--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__DocAdd_ * SOAP_FMAC2 soap_instantiate___tempuri__DocAdd_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__DocAdd_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__DocAdd_ *p;
	size_t k = sizeof(struct __tempuri__DocAdd_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__DocAdd_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__DocAdd_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__DocAdd_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__DocAdd_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__DocAdd_(struct soap *soap, const struct __tempuri__DocAdd_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__DocAdd_(soap, tag ? tag : "-tempuri:DocAdd", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__DocAdd_ * SOAP_FMAC4 soap_get___tempuri__DocAdd_(struct soap *soap, struct __tempuri__DocAdd_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__DocAdd_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDonOver_(struct soap *soap, struct __tempuri__AnDonOver_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDonOver = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDonOver_(struct soap *soap, const struct __tempuri__AnDonOver_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDonOver(soap, &a->tempuri__AnDonOver);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDonOver_(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDonOver_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDonOver(soap, "tempuri:AnDonOver", -1, &a->tempuri__AnDonOver, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDonOver_ * SOAP_FMAC4 soap_in___tempuri__AnDonOver_(struct soap *soap, const char *tag, struct __tempuri__AnDonOver_ *a, const char *type)
{
	size_t soap_flag_tempuri__AnDonOver = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDonOver_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDonOver_, sizeof(struct __tempuri__AnDonOver_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDonOver_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDonOver && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDonOver(soap, "tempuri:AnDonOver", &a->tempuri__AnDonOver, ""))
				{	soap_flag_tempuri__AnDonOver--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDonOver_ * SOAP_FMAC2 soap_instantiate___tempuri__AnDonOver_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDonOver_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDonOver_ *p;
	size_t k = sizeof(struct __tempuri__AnDonOver_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__AnDonOver_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__AnDonOver_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDonOver_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__AnDonOver_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDonOver_(struct soap *soap, const struct __tempuri__AnDonOver_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDonOver_(soap, tag ? tag : "-tempuri:AnDonOver", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDonOver_ * SOAP_FMAC4 soap_get___tempuri__AnDonOver_(struct soap *soap, struct __tempuri__AnDonOver_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDonOver_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDonList_(struct soap *soap, struct __tempuri__AnDonList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDonList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDonList_(struct soap *soap, const struct __tempuri__AnDonList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDonList(soap, &a->tempuri__AnDonList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDonList_(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDonList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDonList(soap, "tempuri:AnDonList", -1, &a->tempuri__AnDonList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDonList_ * SOAP_FMAC4 soap_in___tempuri__AnDonList_(struct soap *soap, const char *tag, struct __tempuri__AnDonList_ *a, const char *type)
{
	size_t soap_flag_tempuri__AnDonList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDonList_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDonList_, sizeof(struct __tempuri__AnDonList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDonList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDonList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDonList(soap, "tempuri:AnDonList", &a->tempuri__AnDonList, ""))
				{	soap_flag_tempuri__AnDonList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDonList_ * SOAP_FMAC2 soap_instantiate___tempuri__AnDonList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDonList_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDonList_ *p;
	size_t k = sizeof(struct __tempuri__AnDonList_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__AnDonList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__AnDonList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDonList_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__AnDonList_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDonList_(struct soap *soap, const struct __tempuri__AnDonList_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDonList_(soap, tag ? tag : "-tempuri:AnDonList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDonList_ * SOAP_FMAC4 soap_get___tempuri__AnDonList_(struct soap *soap, struct __tempuri__AnDonList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDonList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDonStart_(struct soap *soap, struct __tempuri__AnDonStart_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDonStart = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDonStart_(struct soap *soap, const struct __tempuri__AnDonStart_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDonStart(soap, &a->tempuri__AnDonStart);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDonStart_(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDonStart_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDonStart(soap, "tempuri:AnDonStart", -1, &a->tempuri__AnDonStart, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDonStart_ * SOAP_FMAC4 soap_in___tempuri__AnDonStart_(struct soap *soap, const char *tag, struct __tempuri__AnDonStart_ *a, const char *type)
{
	size_t soap_flag_tempuri__AnDonStart = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDonStart_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDonStart_, sizeof(struct __tempuri__AnDonStart_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDonStart_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDonStart && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDonStart(soap, "tempuri:AnDonStart", &a->tempuri__AnDonStart, ""))
				{	soap_flag_tempuri__AnDonStart--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDonStart_ * SOAP_FMAC2 soap_instantiate___tempuri__AnDonStart_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDonStart_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDonStart_ *p;
	size_t k = sizeof(struct __tempuri__AnDonStart_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__AnDonStart_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__AnDonStart_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDonStart_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__AnDonStart_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDonStart_(struct soap *soap, const struct __tempuri__AnDonStart_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDonStart_(soap, tag ? tag : "-tempuri:AnDonStart", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDonStart_ * SOAP_FMAC4 soap_get___tempuri__AnDonStart_(struct soap *soap, struct __tempuri__AnDonStart_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDonStart_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__LineInventory_(struct soap *soap, struct __tempuri__LineInventory_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__LineInventory = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__LineInventory_(struct soap *soap, const struct __tempuri__LineInventory_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__LineInventory(soap, &a->tempuri__LineInventory);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__LineInventory_(struct soap *soap, const char *tag, int id, const struct __tempuri__LineInventory_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__LineInventory(soap, "tempuri:LineInventory", -1, &a->tempuri__LineInventory, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventory_ * SOAP_FMAC4 soap_in___tempuri__LineInventory_(struct soap *soap, const char *tag, struct __tempuri__LineInventory_ *a, const char *type)
{
	size_t soap_flag_tempuri__LineInventory = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__LineInventory_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__LineInventory_, sizeof(struct __tempuri__LineInventory_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__LineInventory_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__LineInventory && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__LineInventory(soap, "tempuri:LineInventory", &a->tempuri__LineInventory, ""))
				{	soap_flag_tempuri__LineInventory--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__LineInventory_ * SOAP_FMAC2 soap_instantiate___tempuri__LineInventory_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__LineInventory_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__LineInventory_ *p;
	size_t k = sizeof(struct __tempuri__LineInventory_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__LineInventory_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__LineInventory_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__LineInventory_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__LineInventory_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__LineInventory_(struct soap *soap, const struct __tempuri__LineInventory_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__LineInventory_(soap, tag ? tag : "-tempuri:LineInventory", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventory_ * SOAP_FMAC4 soap_get___tempuri__LineInventory_(struct soap *soap, struct __tempuri__LineInventory_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__LineInventory_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__BillState_(struct soap *soap, struct __tempuri__BillState_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__BillState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__BillState_(struct soap *soap, const struct __tempuri__BillState_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__BillState(soap, &a->tempuri__BillState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__BillState_(struct soap *soap, const char *tag, int id, const struct __tempuri__BillState_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__BillState(soap, "tempuri:BillState", -1, &a->tempuri__BillState, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__BillState_ * SOAP_FMAC4 soap_in___tempuri__BillState_(struct soap *soap, const char *tag, struct __tempuri__BillState_ *a, const char *type)
{
	size_t soap_flag_tempuri__BillState = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__BillState_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__BillState_, sizeof(struct __tempuri__BillState_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__BillState_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__BillState && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__BillState(soap, "tempuri:BillState", &a->tempuri__BillState, ""))
				{	soap_flag_tempuri__BillState--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__BillState_ * SOAP_FMAC2 soap_instantiate___tempuri__BillState_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__BillState_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__BillState_ *p;
	size_t k = sizeof(struct __tempuri__BillState_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__BillState_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__BillState_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__BillState_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__BillState_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__BillState_(struct soap *soap, const struct __tempuri__BillState_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__BillState_(soap, tag ? tag : "-tempuri:BillState", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__BillState_ * SOAP_FMAC4 soap_get___tempuri__BillState_(struct soap *soap, struct __tempuri__BillState_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__BillState_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__ToolingTimes_(struct soap *soap, struct __tempuri__ToolingTimes_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__ToolingTimes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__ToolingTimes_(struct soap *soap, const struct __tempuri__ToolingTimes_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__ToolingTimes(soap, &a->tempuri__ToolingTimes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__ToolingTimes_(struct soap *soap, const char *tag, int id, const struct __tempuri__ToolingTimes_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__ToolingTimes(soap, "tempuri:ToolingTimes", -1, &a->tempuri__ToolingTimes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__ToolingTimes_ * SOAP_FMAC4 soap_in___tempuri__ToolingTimes_(struct soap *soap, const char *tag, struct __tempuri__ToolingTimes_ *a, const char *type)
{
	size_t soap_flag_tempuri__ToolingTimes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__ToolingTimes_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__ToolingTimes_, sizeof(struct __tempuri__ToolingTimes_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__ToolingTimes_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__ToolingTimes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__ToolingTimes(soap, "tempuri:ToolingTimes", &a->tempuri__ToolingTimes, ""))
				{	soap_flag_tempuri__ToolingTimes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__ToolingTimes_ * SOAP_FMAC2 soap_instantiate___tempuri__ToolingTimes_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__ToolingTimes_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__ToolingTimes_ *p;
	size_t k = sizeof(struct __tempuri__ToolingTimes_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__ToolingTimes_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__ToolingTimes_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__ToolingTimes_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__ToolingTimes_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__ToolingTimes_(struct soap *soap, const struct __tempuri__ToolingTimes_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__ToolingTimes_(soap, tag ? tag : "-tempuri:ToolingTimes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__ToolingTimes_ * SOAP_FMAC4 soap_get___tempuri__ToolingTimes_(struct soap *soap, struct __tempuri__ToolingTimes_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__ToolingTimes_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__test_(struct soap *soap, struct __tempuri__test_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__test = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__test_(struct soap *soap, const struct __tempuri__test_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__test(soap, &a->tempuri__test);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__test_(struct soap *soap, const char *tag, int id, const struct __tempuri__test_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__test(soap, "tempuri:test", -1, &a->tempuri__test, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__test_ * SOAP_FMAC4 soap_in___tempuri__test_(struct soap *soap, const char *tag, struct __tempuri__test_ *a, const char *type)
{
	size_t soap_flag_tempuri__test = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__test_ *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__test_, sizeof(struct __tempuri__test_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__test_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__test && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__test(soap, "tempuri:test", &a->tempuri__test, ""))
				{	soap_flag_tempuri__test--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__test_ * SOAP_FMAC2 soap_instantiate___tempuri__test_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__test_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__test_ *p;
	size_t k = sizeof(struct __tempuri__test_);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__test_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__test_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__test_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__test_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__test_(struct soap *soap, const struct __tempuri__test_ *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__test_(soap, tag ? tag : "-tempuri:test", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__test_ * SOAP_FMAC4 soap_get___tempuri__test_(struct soap *soap, struct __tempuri__test_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__test_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__DocAdd(struct soap *soap, struct __tempuri__DocAdd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__DocAdd = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__DocAdd(struct soap *soap, const struct __tempuri__DocAdd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__DocAdd(soap, &a->tempuri__DocAdd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__DocAdd(struct soap *soap, const char *tag, int id, const struct __tempuri__DocAdd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__DocAdd(soap, "tempuri:DocAdd", -1, &a->tempuri__DocAdd, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__DocAdd * SOAP_FMAC4 soap_in___tempuri__DocAdd(struct soap *soap, const char *tag, struct __tempuri__DocAdd *a, const char *type)
{
	size_t soap_flag_tempuri__DocAdd = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__DocAdd *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__DocAdd, sizeof(struct __tempuri__DocAdd), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__DocAdd(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__DocAdd && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__DocAdd(soap, "tempuri:DocAdd", &a->tempuri__DocAdd, ""))
				{	soap_flag_tempuri__DocAdd--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__DocAdd * SOAP_FMAC2 soap_instantiate___tempuri__DocAdd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__DocAdd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__DocAdd *p;
	size_t k = sizeof(struct __tempuri__DocAdd);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__DocAdd);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__DocAdd, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__DocAdd location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__DocAdd, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__DocAdd(struct soap *soap, const struct __tempuri__DocAdd *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__DocAdd(soap, tag ? tag : "-tempuri:DocAdd", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__DocAdd * SOAP_FMAC4 soap_get___tempuri__DocAdd(struct soap *soap, struct __tempuri__DocAdd *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__DocAdd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDonOver(struct soap *soap, struct __tempuri__AnDonOver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDonOver = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDonOver(struct soap *soap, const struct __tempuri__AnDonOver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDonOver(soap, &a->tempuri__AnDonOver);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDonOver(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDonOver *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDonOver(soap, "tempuri:AnDonOver", -1, &a->tempuri__AnDonOver, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDonOver * SOAP_FMAC4 soap_in___tempuri__AnDonOver(struct soap *soap, const char *tag, struct __tempuri__AnDonOver *a, const char *type)
{
	size_t soap_flag_tempuri__AnDonOver = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDonOver *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDonOver, sizeof(struct __tempuri__AnDonOver), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDonOver(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDonOver && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDonOver(soap, "tempuri:AnDonOver", &a->tempuri__AnDonOver, ""))
				{	soap_flag_tempuri__AnDonOver--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDonOver * SOAP_FMAC2 soap_instantiate___tempuri__AnDonOver(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDonOver(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDonOver *p;
	size_t k = sizeof(struct __tempuri__AnDonOver);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__AnDonOver);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__AnDonOver, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDonOver location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__AnDonOver, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDonOver(struct soap *soap, const struct __tempuri__AnDonOver *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDonOver(soap, tag ? tag : "-tempuri:AnDonOver", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDonOver * SOAP_FMAC4 soap_get___tempuri__AnDonOver(struct soap *soap, struct __tempuri__AnDonOver *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDonOver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDonList(struct soap *soap, struct __tempuri__AnDonList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDonList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDonList(struct soap *soap, const struct __tempuri__AnDonList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDonList(soap, &a->tempuri__AnDonList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDonList(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDonList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDonList(soap, "tempuri:AnDonList", -1, &a->tempuri__AnDonList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDonList * SOAP_FMAC4 soap_in___tempuri__AnDonList(struct soap *soap, const char *tag, struct __tempuri__AnDonList *a, const char *type)
{
	size_t soap_flag_tempuri__AnDonList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDonList *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDonList, sizeof(struct __tempuri__AnDonList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDonList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDonList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDonList(soap, "tempuri:AnDonList", &a->tempuri__AnDonList, ""))
				{	soap_flag_tempuri__AnDonList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDonList * SOAP_FMAC2 soap_instantiate___tempuri__AnDonList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDonList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDonList *p;
	size_t k = sizeof(struct __tempuri__AnDonList);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__AnDonList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__AnDonList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDonList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__AnDonList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDonList(struct soap *soap, const struct __tempuri__AnDonList *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDonList(soap, tag ? tag : "-tempuri:AnDonList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDonList * SOAP_FMAC4 soap_get___tempuri__AnDonList(struct soap *soap, struct __tempuri__AnDonList *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDonList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__AnDonStart(struct soap *soap, struct __tempuri__AnDonStart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__AnDonStart = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__AnDonStart(struct soap *soap, const struct __tempuri__AnDonStart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__AnDonStart(soap, &a->tempuri__AnDonStart);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__AnDonStart(struct soap *soap, const char *tag, int id, const struct __tempuri__AnDonStart *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__AnDonStart(soap, "tempuri:AnDonStart", -1, &a->tempuri__AnDonStart, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDonStart * SOAP_FMAC4 soap_in___tempuri__AnDonStart(struct soap *soap, const char *tag, struct __tempuri__AnDonStart *a, const char *type)
{
	size_t soap_flag_tempuri__AnDonStart = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__AnDonStart *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__AnDonStart, sizeof(struct __tempuri__AnDonStart), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__AnDonStart(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__AnDonStart && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__AnDonStart(soap, "tempuri:AnDonStart", &a->tempuri__AnDonStart, ""))
				{	soap_flag_tempuri__AnDonStart--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__AnDonStart * SOAP_FMAC2 soap_instantiate___tempuri__AnDonStart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__AnDonStart(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__AnDonStart *p;
	size_t k = sizeof(struct __tempuri__AnDonStart);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__AnDonStart);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__AnDonStart, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__AnDonStart location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__AnDonStart, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__AnDonStart(struct soap *soap, const struct __tempuri__AnDonStart *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__AnDonStart(soap, tag ? tag : "-tempuri:AnDonStart", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__AnDonStart * SOAP_FMAC4 soap_get___tempuri__AnDonStart(struct soap *soap, struct __tempuri__AnDonStart *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__AnDonStart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__LineInventory(struct soap *soap, struct __tempuri__LineInventory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__LineInventory = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__LineInventory(struct soap *soap, const struct __tempuri__LineInventory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__LineInventory(soap, &a->tempuri__LineInventory);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__LineInventory(struct soap *soap, const char *tag, int id, const struct __tempuri__LineInventory *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__LineInventory(soap, "tempuri:LineInventory", -1, &a->tempuri__LineInventory, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventory * SOAP_FMAC4 soap_in___tempuri__LineInventory(struct soap *soap, const char *tag, struct __tempuri__LineInventory *a, const char *type)
{
	size_t soap_flag_tempuri__LineInventory = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__LineInventory *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__LineInventory, sizeof(struct __tempuri__LineInventory), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__LineInventory(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__LineInventory && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__LineInventory(soap, "tempuri:LineInventory", &a->tempuri__LineInventory, ""))
				{	soap_flag_tempuri__LineInventory--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__LineInventory * SOAP_FMAC2 soap_instantiate___tempuri__LineInventory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__LineInventory(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__LineInventory *p;
	size_t k = sizeof(struct __tempuri__LineInventory);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__LineInventory);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__LineInventory, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__LineInventory location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__LineInventory, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__LineInventory(struct soap *soap, const struct __tempuri__LineInventory *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__LineInventory(soap, tag ? tag : "-tempuri:LineInventory", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__LineInventory * SOAP_FMAC4 soap_get___tempuri__LineInventory(struct soap *soap, struct __tempuri__LineInventory *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__LineInventory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__BillState(struct soap *soap, struct __tempuri__BillState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__BillState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__BillState(struct soap *soap, const struct __tempuri__BillState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__BillState(soap, &a->tempuri__BillState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__BillState(struct soap *soap, const char *tag, int id, const struct __tempuri__BillState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__BillState(soap, "tempuri:BillState", -1, &a->tempuri__BillState, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__BillState * SOAP_FMAC4 soap_in___tempuri__BillState(struct soap *soap, const char *tag, struct __tempuri__BillState *a, const char *type)
{
	size_t soap_flag_tempuri__BillState = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__BillState *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__BillState, sizeof(struct __tempuri__BillState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__BillState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__BillState && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__BillState(soap, "tempuri:BillState", &a->tempuri__BillState, ""))
				{	soap_flag_tempuri__BillState--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__BillState * SOAP_FMAC2 soap_instantiate___tempuri__BillState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__BillState(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__BillState *p;
	size_t k = sizeof(struct __tempuri__BillState);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__BillState);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__BillState, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__BillState location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__BillState, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__BillState(struct soap *soap, const struct __tempuri__BillState *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__BillState(soap, tag ? tag : "-tempuri:BillState", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__BillState * SOAP_FMAC4 soap_get___tempuri__BillState(struct soap *soap, struct __tempuri__BillState *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__BillState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__ToolingTimes(struct soap *soap, struct __tempuri__ToolingTimes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__ToolingTimes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__ToolingTimes(struct soap *soap, const struct __tempuri__ToolingTimes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__ToolingTimes(soap, &a->tempuri__ToolingTimes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__ToolingTimes(struct soap *soap, const char *tag, int id, const struct __tempuri__ToolingTimes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__ToolingTimes(soap, "tempuri:ToolingTimes", -1, &a->tempuri__ToolingTimes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__ToolingTimes * SOAP_FMAC4 soap_in___tempuri__ToolingTimes(struct soap *soap, const char *tag, struct __tempuri__ToolingTimes *a, const char *type)
{
	size_t soap_flag_tempuri__ToolingTimes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__ToolingTimes *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__ToolingTimes, sizeof(struct __tempuri__ToolingTimes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__ToolingTimes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__ToolingTimes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__ToolingTimes(soap, "tempuri:ToolingTimes", &a->tempuri__ToolingTimes, ""))
				{	soap_flag_tempuri__ToolingTimes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__ToolingTimes * SOAP_FMAC2 soap_instantiate___tempuri__ToolingTimes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__ToolingTimes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__ToolingTimes *p;
	size_t k = sizeof(struct __tempuri__ToolingTimes);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__ToolingTimes);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__ToolingTimes, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__ToolingTimes location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__ToolingTimes, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__ToolingTimes(struct soap *soap, const struct __tempuri__ToolingTimes *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__ToolingTimes(soap, tag ? tag : "-tempuri:ToolingTimes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__ToolingTimes * SOAP_FMAC4 soap_get___tempuri__ToolingTimes(struct soap *soap, struct __tempuri__ToolingTimes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__ToolingTimes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tempuri__test(struct soap *soap, struct __tempuri__test *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tempuri__test = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tempuri__test(struct soap *soap, const struct __tempuri__test *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tempuri__test(soap, &a->tempuri__test);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tempuri__test(struct soap *soap, const char *tag, int id, const struct __tempuri__test *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tempuri__test(soap, "tempuri:test", -1, &a->tempuri__test, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__test * SOAP_FMAC4 soap_in___tempuri__test(struct soap *soap, const char *tag, struct __tempuri__test *a, const char *type)
{
	size_t soap_flag_tempuri__test = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tempuri__test *)soap_id_enter(soap, "", a, SOAP_TYPE___tempuri__test, sizeof(struct __tempuri__test), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tempuri__test(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tempuri__test && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tempuri__test(soap, "tempuri:test", &a->tempuri__test, ""))
				{	soap_flag_tempuri__test--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tempuri__test * SOAP_FMAC2 soap_instantiate___tempuri__test(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tempuri__test(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tempuri__test *p;
	size_t k = sizeof(struct __tempuri__test);
	if (n < 0)
	{	p = SOAP_NEW(struct __tempuri__test);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __tempuri__test, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tempuri__test location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___tempuri__test, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tempuri__test(struct soap *soap, const struct __tempuri__test *a, const char *tag, const char *type)
{
	if (soap_out___tempuri__test(soap, tag ? tag : "-tempuri:test", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tempuri__test * SOAP_FMAC4 soap_get___tempuri__test(struct soap *soap, struct __tempuri__test *p, const char *tag, const char *type)
{
	if ((p = soap_in___tempuri__test(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__DocAdd(struct soap *soap, _tempuri__DocAdd *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__DocAdd))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__DocAdd(struct soap *soap, const char *tag, int id, _tempuri__DocAdd *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__DocAdd, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__DocAdd ? type : NULL);
}

SOAP_FMAC3 _tempuri__DocAdd ** SOAP_FMAC4 soap_in_PointerTo_tempuri__DocAdd(struct soap *soap, const char *tag, _tempuri__DocAdd **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__DocAdd **)soap_malloc(soap, sizeof(_tempuri__DocAdd *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__DocAdd *)soap_instantiate__tempuri__DocAdd(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__DocAdd **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__DocAdd, sizeof(_tempuri__DocAdd), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__DocAdd(struct soap *soap, _tempuri__DocAdd *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__DocAdd(soap, tag ? tag : "tempuri:DocAdd", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__DocAdd ** SOAP_FMAC4 soap_get_PointerTo_tempuri__DocAdd(struct soap *soap, _tempuri__DocAdd **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__DocAdd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__AnDonOver(struct soap *soap, _tempuri__AnDonOver *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__AnDonOver))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__AnDonOver(struct soap *soap, const char *tag, int id, _tempuri__AnDonOver *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__AnDonOver, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__AnDonOver ? type : NULL);
}

SOAP_FMAC3 _tempuri__AnDonOver ** SOAP_FMAC4 soap_in_PointerTo_tempuri__AnDonOver(struct soap *soap, const char *tag, _tempuri__AnDonOver **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__AnDonOver **)soap_malloc(soap, sizeof(_tempuri__AnDonOver *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__AnDonOver *)soap_instantiate__tempuri__AnDonOver(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__AnDonOver **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__AnDonOver, sizeof(_tempuri__AnDonOver), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__AnDonOver(struct soap *soap, _tempuri__AnDonOver *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__AnDonOver(soap, tag ? tag : "tempuri:AnDonOver", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__AnDonOver ** SOAP_FMAC4 soap_get_PointerTo_tempuri__AnDonOver(struct soap *soap, _tempuri__AnDonOver **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__AnDonOver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__AnDonList(struct soap *soap, _tempuri__AnDonList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__AnDonList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__AnDonList(struct soap *soap, const char *tag, int id, _tempuri__AnDonList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__AnDonList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__AnDonList ? type : NULL);
}

SOAP_FMAC3 _tempuri__AnDonList ** SOAP_FMAC4 soap_in_PointerTo_tempuri__AnDonList(struct soap *soap, const char *tag, _tempuri__AnDonList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__AnDonList **)soap_malloc(soap, sizeof(_tempuri__AnDonList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__AnDonList *)soap_instantiate__tempuri__AnDonList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__AnDonList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__AnDonList, sizeof(_tempuri__AnDonList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__AnDonList(struct soap *soap, _tempuri__AnDonList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__AnDonList(soap, tag ? tag : "tempuri:AnDonList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__AnDonList ** SOAP_FMAC4 soap_get_PointerTo_tempuri__AnDonList(struct soap *soap, _tempuri__AnDonList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__AnDonList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__AnDonStart(struct soap *soap, _tempuri__AnDonStart *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__AnDonStart))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__AnDonStart(struct soap *soap, const char *tag, int id, _tempuri__AnDonStart *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__AnDonStart, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__AnDonStart ? type : NULL);
}

SOAP_FMAC3 _tempuri__AnDonStart ** SOAP_FMAC4 soap_in_PointerTo_tempuri__AnDonStart(struct soap *soap, const char *tag, _tempuri__AnDonStart **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__AnDonStart **)soap_malloc(soap, sizeof(_tempuri__AnDonStart *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__AnDonStart *)soap_instantiate__tempuri__AnDonStart(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__AnDonStart **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__AnDonStart, sizeof(_tempuri__AnDonStart), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__AnDonStart(struct soap *soap, _tempuri__AnDonStart *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__AnDonStart(soap, tag ? tag : "tempuri:AnDonStart", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__AnDonStart ** SOAP_FMAC4 soap_get_PointerTo_tempuri__AnDonStart(struct soap *soap, _tempuri__AnDonStart **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__AnDonStart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__LineInventory(struct soap *soap, _tempuri__LineInventory *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__LineInventory))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__LineInventory(struct soap *soap, const char *tag, int id, _tempuri__LineInventory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__LineInventory, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__LineInventory ? type : NULL);
}

SOAP_FMAC3 _tempuri__LineInventory ** SOAP_FMAC4 soap_in_PointerTo_tempuri__LineInventory(struct soap *soap, const char *tag, _tempuri__LineInventory **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__LineInventory **)soap_malloc(soap, sizeof(_tempuri__LineInventory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__LineInventory *)soap_instantiate__tempuri__LineInventory(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__LineInventory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__LineInventory, sizeof(_tempuri__LineInventory), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__LineInventory(struct soap *soap, _tempuri__LineInventory *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__LineInventory(soap, tag ? tag : "tempuri:LineInventory", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__LineInventory ** SOAP_FMAC4 soap_get_PointerTo_tempuri__LineInventory(struct soap *soap, _tempuri__LineInventory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__LineInventory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__BillState(struct soap *soap, _tempuri__BillState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__BillState))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__BillState(struct soap *soap, const char *tag, int id, _tempuri__BillState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__BillState, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__BillState ? type : NULL);
}

SOAP_FMAC3 _tempuri__BillState ** SOAP_FMAC4 soap_in_PointerTo_tempuri__BillState(struct soap *soap, const char *tag, _tempuri__BillState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__BillState **)soap_malloc(soap, sizeof(_tempuri__BillState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__BillState *)soap_instantiate__tempuri__BillState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__BillState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__BillState, sizeof(_tempuri__BillState), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__BillState(struct soap *soap, _tempuri__BillState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__BillState(soap, tag ? tag : "tempuri:BillState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__BillState ** SOAP_FMAC4 soap_get_PointerTo_tempuri__BillState(struct soap *soap, _tempuri__BillState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__BillState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__ToolingTimes(struct soap *soap, _tempuri__ToolingTimes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__ToolingTimes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__ToolingTimes(struct soap *soap, const char *tag, int id, _tempuri__ToolingTimes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__ToolingTimes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__ToolingTimes ? type : NULL);
}

SOAP_FMAC3 _tempuri__ToolingTimes ** SOAP_FMAC4 soap_in_PointerTo_tempuri__ToolingTimes(struct soap *soap, const char *tag, _tempuri__ToolingTimes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__ToolingTimes **)soap_malloc(soap, sizeof(_tempuri__ToolingTimes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__ToolingTimes *)soap_instantiate__tempuri__ToolingTimes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__ToolingTimes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__ToolingTimes, sizeof(_tempuri__ToolingTimes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__ToolingTimes(struct soap *soap, _tempuri__ToolingTimes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__ToolingTimes(soap, tag ? tag : "tempuri:ToolingTimes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__ToolingTimes ** SOAP_FMAC4 soap_get_PointerTo_tempuri__ToolingTimes(struct soap *soap, _tempuri__ToolingTimes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__ToolingTimes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tempuri__test(struct soap *soap, _tempuri__test *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tempuri__test))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tempuri__test(struct soap *soap, const char *tag, int id, _tempuri__test *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tempuri__test, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tempuri__test ? type : NULL);
}

SOAP_FMAC3 _tempuri__test ** SOAP_FMAC4 soap_in_PointerTo_tempuri__test(struct soap *soap, const char *tag, _tempuri__test **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tempuri__test **)soap_malloc(soap, sizeof(_tempuri__test *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tempuri__test *)soap_instantiate__tempuri__test(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tempuri__test **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tempuri__test, sizeof(_tempuri__test), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tempuri__test(struct soap *soap, _tempuri__test *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tempuri__test(soap, tag ? tag : "tempuri:test", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tempuri__test ** SOAP_FMAC4 soap_get_PointerTo_tempuri__test(struct soap *soap, _tempuri__test **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tempuri__test(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
